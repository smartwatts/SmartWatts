name: Deploy Staging (main branch)

on:
  push:
    branches: [ "main" ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'infrastructure/**'
      - 'azure-deployment/**'
      - '.github/workflows/deploy-staging.yml'
      - '!docs/**'
      - '!*.md'
      - '!.github/workflows/*.md'
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-staging-rg
  ENVIRONMENT: staging
  LOCATION: centralus
  VM_NAME: sw-staging-vm
  VM_ADMIN_USERNAME: azureuser
  TEMPLATE_FILE: infrastructure/bicep/main.bicep
  PARAM_FILE: infrastructure/bicep/params.staging.json
  PUBLIC_IP_NAME: sw-staging-vm-pip

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_STAGING }}

      - name: Check and Recreate Resource Group
        timeout-minutes: 5
        run: |
          # Check if resource group exists
          if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            CURRENT_LOCATION=$(az group show --name ${{ env.AZURE_RESOURCE_GROUP }} --query location -o tsv)
            echo "Resource group exists in location: $CURRENT_LOCATION"
            
            # If location doesn't match, delete and recreate
            if [ "$CURRENT_LOCATION" != "${{ env.LOCATION }}" ]; then
              echo "‚ö†Ô∏è  Resource group is in $CURRENT_LOCATION, but we need ${{ env.LOCATION }}"
              echo "üóëÔ∏è  Deleting existing resource group to recreate in ${{ env.LOCATION }}..."
              az group delete --name ${{ env.AZURE_RESOURCE_GROUP }} --yes --no-wait
              echo "‚è≥ Waiting for deletion to complete (this may take a few minutes)..."
              
              # Wait for deletion (max 10 minutes)
              MAX_WAIT=600
              ELAPSED=0
              while az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null && [ $ELAPSED -lt $MAX_WAIT ]; do
                echo -n "."
                sleep 10
                ELAPSED=$((ELAPSED + 10))
              done
              echo ""
              
              if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
                echo "‚ùå Error: Resource group deletion timed out"
                echo "Please delete it manually: az group delete --name ${{ env.AZURE_RESOURCE_GROUP }} --yes"
                exit 1
              else
                echo "‚úÖ Resource group deleted successfully"
              fi
            else
              echo "‚úÖ Resource group is already in the correct location"
            fi
          fi
          
          # Create resource group if it doesn't exist
          if ! az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "üì¶ Creating resource group in ${{ env.LOCATION }}..."
            az group create \
              --name ${{ env.AZURE_RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }} \
              --output none
            echo "‚úÖ Resource group created"
          fi

      - name: Check if VM exists
        id: vmcheck
        run: |
          echo "Checking if ${{ env.VM_NAME }} exists in resource group ${{ env.AZURE_RESOURCE_GROUP }}"
          if az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "VM already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "VM does not exist - will be created"
          fi

      - name: Extract SSH public key from secret
        id: sshkey
        run: |
          set -e
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_STAGING }}"
          
          if [ -z "$SSH_KEY" ]; then
            echo "‚ùå Error: VM_SSH_PRIVATE_KEY_STAGING secret is empty or not set"
            echo "Please set the VM_SSH_PRIVATE_KEY_STAGING secret in GitHub repository settings"
            exit 1
          fi
          
          echo "Processing SSH key..."
          
          # Write private key temporarily to extract public key
          # First, try to detect if it's base64 encoded (OpenSSH keys are often base64 encoded)
          # Check if it starts with base64 characters and doesn't contain "BEGIN"
          if echo "$SSH_KEY" | grep -q "BEGIN.*PRIVATE KEY"; then
            # Key is already in PEM format (plain text)
            echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
            echo "Detected PEM format (plain text)"
          else
            # Try base64 decode first (OpenSSH keys are often base64 encoded)
            echo "Attempting base64 decode..."
            if echo "$SSH_KEY" | base64 -d > ~/.ssh/temp_key 2>/dev/null; then
              # Check what we got after decoding
              FIRST_BYTES=$(head -c 20 ~/.ssh/temp_key 2>/dev/null || echo "")
              if echo "$FIRST_BYTES" | grep -q "openssh-key-v1"; then
                echo "‚úÖ Decoded base64 OpenSSH format key"
              elif echo "$FIRST_BYTES" | grep -q "BEGIN.*PRIVATE KEY"; then
                echo "‚úÖ Decoded base64 PEM format key"
              else
                echo "‚ö†Ô∏è  Base64 decode succeeded but format unclear, trying as plain text..."
                echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
              fi
            else
              # Base64 decode failed, try as plain text
              echo "Base64 decode failed, trying as plain text..."
              echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
            fi
          fi
          chmod 600 ~/.ssh/temp_key
          
          # Validate key file before proceeding
          echo "Validating key file..."
          if [ ! -f ~/.ssh/temp_key ]; then
            echo "‚ùå Error: Key file was not created"
            exit 1
          fi
          
          KEY_SIZE=$(wc -c < ~/.ssh/temp_key 2>/dev/null || echo "0")
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå Error: Key file is too small ($KEY_SIZE bytes) - likely corrupted"
            exit 1
          fi
          
          KEY_TYPE=$(file ~/.ssh/temp_key 2>/dev/null || echo "unknown")
          echo "Key file type: $KEY_TYPE"
          echo "Key file size: $KEY_SIZE bytes"
          echo "Key file permissions: $(stat -c '%a' ~/.ssh/temp_key 2>/dev/null || stat -f '%A' ~/.ssh/temp_key 2>/dev/null || echo 'unknown')"
          
          # Check key format and convert if needed
          FIRST_BYTES=$(head -c 20 ~/.ssh/temp_key 2>/dev/null || echo "")
          echo "Key file first 20 bytes: $(echo "$FIRST_BYTES" | xxd -p | head -c 40)"
          
          # Validate key - OpenSSH format keys can be used directly with modern SSH
          # First, try to extract public key to validate
          if ssh-keygen -y -f ~/.ssh/temp_key > /dev/null 2>&1; then
            echo "‚úÖ Key validation passed - can extract public key"
          else
            echo "Key validation failed, checking format..."
            # Check if it's OpenSSH format
            if echo "$FIRST_BYTES" | grep -q "openssh-key-v1"; then
              echo "Detected OpenSSH format key"
              echo "Modern SSH supports OpenSSH format, but extraction failed"
              echo "This might indicate the key is encrypted or corrupted"
              echo "Attempting to use key as-is (SSH client may handle it)..."
              
              # Try to extract public key with verbose output to see the error
              SSH_KEYGEN_OUTPUT=$(ssh-keygen -y -f ~/.ssh/temp_key 2>&1 || true)
              echo "ssh-keygen output: $SSH_KEYGEN_OUTPUT"
              
              # If it's an encrypted key, we can't proceed
              if echo "$SSH_KEYGEN_OUTPUT" | grep -qi "encrypted\|passphrase"; then
                echo "‚ùå Error: Key appears to be encrypted"
                echo "Please provide an unencrypted private key"
                exit 1
              fi
              
              # Try one more time - sometimes OpenSSH keys work even if validation fails
              if ! ssh-keygen -y -f ~/.ssh/temp_key > /dev/null 2>&1; then
                echo "‚ö†Ô∏è  Warning: Cannot extract public key from OpenSSH format key"
                echo "This is OK - modern SSH clients support OpenSSH format keys directly"
                echo "The private key will be used for SSH connections"
                echo "Key file info:"
                file ~/.ssh/temp_key 2>/dev/null || echo "Could not determine file type"
                echo "Key file size: $(wc -c < ~/.ssh/temp_key) bytes"
                echo "Continuing workflow with private key only..."
                # Don't exit - continue with private key
              fi
            else
              echo "‚ùå Error: Invalid SSH key format"
              echo "Key file type: $(file ~/.ssh/temp_key 2>/dev/null || echo 'unknown')"
              echo "Key file first 5 lines:"
              head -5 ~/.ssh/temp_key || echo "Could not read key file"
              exit 1
            fi
          fi
          
          # Try to extract public key (may fail for OpenSSH format, but that's OK)
          SSH_PUBLIC_KEY=$(ssh-keygen -y -f ~/.ssh/temp_key 2>/dev/null || echo "")
          
          if [ -n "$SSH_PUBLIC_KEY" ]; then
            echo "‚úÖ SSH public key extracted successfully"
            echo "public_key=$SSH_PUBLIC_KEY" >> $GITHUB_OUTPUT
            
            # Save public key to file
            echo "$SSH_PUBLIC_KEY" > ~/.ssh/id_rsa.pub
            chmod 644 ~/.ssh/id_rsa.pub
            echo "‚úÖ Public key saved for Bicep deployment"
          else
            echo "‚ö†Ô∏è  Warning: Could not extract SSH public key from private key"
            echo "This is OK - we'll use the key directly for SSH connections"
            echo "The VM will be created without SSH key in Bicep, but we'll add it via Azure CLI"
            echo "public_key=" >> $GITHUB_OUTPUT
          fi
          
          # Save private key for SSH connection (OpenSSH format is supported by modern SSH)
          echo "Copying key to id_rsa..."
          cp ~/.ssh/temp_key ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Verify id_rsa was created correctly
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: Failed to create ~/.ssh/id_rsa"
            exit 1
          fi
          
          ID_RSA_PERMS=$(stat -c '%a' ~/.ssh/id_rsa 2>/dev/null || stat -f '%A' ~/.ssh/id_rsa 2>/dev/null || echo "unknown")
          if [ "$ID_RSA_PERMS" != "600" ] && [ "$ID_RSA_PERMS" != "0600" ]; then
            echo "‚ö†Ô∏è  Warning: id_rsa permissions are $ID_RSA_PERMS, expected 600. Fixing..."
            chmod 600 ~/.ssh/id_rsa
            ID_RSA_PERMS=$(stat -c '%a' ~/.ssh/id_rsa 2>/dev/null || stat -f '%A' ~/.ssh/id_rsa 2>/dev/null || echo "unknown")
            echo "‚úÖ id_rsa permissions now: $ID_RSA_PERMS"
          else
            echo "‚úÖ id_rsa permissions correct: $ID_RSA_PERMS"
          fi
          
          # Verify key file is readable
          if [ ! -r ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: id_rsa is not readable"
            exit 1
          fi
          
          echo "‚úÖ SSH key setup complete"
          echo "Key file: ~/.ssh/id_rsa"
          echo "Key size: $(wc -c < ~/.ssh/id_rsa) bytes"
          echo "Key type: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          echo "‚úÖ SSH private key saved successfully"
          echo "Key file location: ~/.ssh/id_rsa"
          echo "Key file permissions: $(ls -l ~/.ssh/id_rsa | awk '{print $1}')"
          echo "Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
          echo "Key format: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          # Note: We don't validate with ssh-keygen -y because OpenSSH format keys
          # may not support this, but they work fine with SSH clients
          
          rm -f ~/.ssh/temp_key
          
      - name: Verify SSH key setup
        run: |
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: SSH private key file not found at ~/.ssh/id_rsa"
            echo "The SSH key extraction step must have failed"
            exit 1
          fi
          
          echo "‚úÖ SSH private key file found"
          echo "Private key: ~/.ssh/id_rsa ($(stat -c%s ~/.ssh/id_rsa 2>/dev/null || stat -f%z ~/.ssh/id_rsa 2>/dev/null) bytes)"
          echo "Key format: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          # Public key is optional (may not be extractable from OpenSSH format)
          if [ -f ~/.ssh/id_rsa.pub ]; then
            echo "‚úÖ SSH public key file found"
            echo "Public key: ~/.ssh/id_rsa.pub"
            echo "Public key fingerprint: $(ssh-keygen -lf ~/.ssh/id_rsa.pub 2>/dev/null | awk '{print $2}' || echo 'N/A')"
          else
            echo "‚ö†Ô∏è  SSH public key file not found (this is OK for OpenSSH format keys)"
            echo "The key will be used directly for SSH connections"
          fi
          
          echo "‚úÖ SSH key setup verified - ready for SSH connections"

      - name: Check if Key Vault exists
        id: kvcheck
        run: |
          # Key Vault names are globally unique, so check across all resource groups
          # First try to find it in any resource group
          KV_EXISTS=$(az keyvault list --query "[?name=='sw-staging-kv'] | length(@)" -o tsv 2>/dev/null || echo "0")
          
          # Also check for soft-deleted Key Vaults
          KV_DELETED=$(az keyvault list-deleted --query "[?name=='sw-staging-kv'] | length(@)" -o tsv 2>/dev/null || echo "0")
          
          if [ "$KV_EXISTS" != "0" ] || [ "$KV_DELETED" != "0" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            if [ "$KV_DELETED" != "0" ]; then
              echo "‚ö†Ô∏è  Key Vault exists in soft-deleted state - will not create"
            else
              echo "‚úÖ Key Vault already exists globally"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "üì¶ Key Vault does not exist - will be created"
          fi

      - name: Deploy Infrastructure via Bicep
        id: deploy
        timeout-minutes: 20
        run: |
          set -e
          DEPLOY_CMD="az deployment group create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name main \
            --template-file ${{ env.TEMPLATE_FILE }} \
            --parameters @${{ env.PARAM_FILE }} \
            --parameters vmAdminPassword=\"${{ secrets.VM_ADMIN_PASSWORD_STAGING }}\" \
            --parameters createKeyVault=$([ "${{ steps.kvcheck.outputs.exists }}" = "true" ] && echo "false" || echo "true") \
            --mode Incremental"

          # Only pass SSH key if VM doesn't already exist and we have a public key
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ]; then
            if [ -n "${{ steps.sshkey.outputs.public_key }}" ]; then
              echo "VM not found. Injecting SSH key for initial creation."
              DEPLOY_CMD="$DEPLOY_CMD --parameters vmSshPublicKey=\"${{ steps.sshkey.outputs.public_key }}\""
              echo "‚úÖ Adding SSH public key to Bicep deployment"
            else
              echo "‚ö†Ô∏è  No SSH public key available - VM will be created without SSH key in Bicep"
              echo "SSH connections will use the private key directly (OpenSSH format supported)"
            fi
          else
            echo "VM already exists. Skipping vmSshPublicKey parameter (Azure doesn't allow updating SSH keys via Bicep)."
          fi

          echo "Running deployment command..."
          eval "$DEPLOY_CMD"

      - name: Retrieve VM Public IP
        id: get_ip
        run: |
          VM_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.PUBLIC_IP_NAME }} \
            --query "ipAddress" -o tsv)
          echo "VM_IP=$VM_IP" >> $GITHUB_ENV
          echo "VM IP: $VM_IP"

      - name: Update VM SSH key (if VM already existed)
        if: steps.vmcheck.outputs.exists == 'true' && steps.sshkey.outputs.public_key != ''
        run: |
          echo "Updating VM authorized_keys using Azure CLI..."
          if az vm user update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --username ${{ env.VM_ADMIN_USERNAME }} \
            --ssh-key-value "${{ steps.sshkey.outputs.public_key }}" 2>&1; then
            echo "‚úÖ SSH key updated successfully"
            echo "Waiting 30 seconds for key to propagate..."
            sleep 30
          else
            echo "‚ö†Ô∏è Warning: Failed to update SSH key via Azure CLI"
            echo "You may need to manually add the SSH key or recreate the VM"
          fi

      - name: Verify SSH Connection
        timeout-minutes: 5
        continue-on-error: true
        run: |
          MAX_RETRIES=5
          RETRY_DELAY=15
          COUNT=0

          echo "Verifying SSH connection to ${{ env.VM_IP }}..."
          
          # Check NSG rules
          echo "Checking NSG rules for SSH access..."
          NSG_NAME=$(az network nsg list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[?contains(name, 'nsg')].name" -o tsv | head -1)
          if [ -n "$NSG_NAME" ]; then
            echo "NSG: $NSG_NAME"
            az network nsg rule list --nsg-name "$NSG_NAME" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[?destinationPortRange=='22']" -o table || echo "Could not list NSG rules"
          fi
          
          # Check if SSH service is accessible
          echo "Testing SSH port connectivity..."
          timeout 5 bash -c "echo > /dev/tcp/${{ env.VM_IP }}/22" 2>/dev/null && echo "‚úÖ Port 22 is open" || echo "‚ö†Ô∏è  Port 22 may be blocked or SSH service not running"
          
          # Add VM to known_hosts (non-blocking)
          ssh-keyscan -H ${{ env.VM_IP }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add VM to known_hosts (will continue)"

          # Verify SSH key file exists
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ö†Ô∏è  Warning: SSH private key file not found at ~/.ssh/id_rsa"
            echo "SSH connection will likely fail. Continuing anyway..."
          else
            echo "‚úÖ SSH private key file found"
            # Test SSH connection with verbose output for first attempt
            until ssh -i ~/.ssh/id_rsa \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ConnectTimeout=10 \
              -o BatchMode=yes \
              -v ${{ env.VM_ADMIN_USERNAME }}@${{ env.VM_IP }} 'echo "SSH connection successful"' 2>&1 | tee /tmp/ssh_debug.log \
              || [ $COUNT -eq $MAX_RETRIES ]; do
                echo "Attempt $((COUNT + 1)) of $MAX_RETRIES failed. Retrying in $RETRY_DELAY seconds..."
                if [ $COUNT -eq 0 ]; then
                  echo "First attempt SSH debug output:"
                  tail -20 /tmp/ssh_debug.log 2>/dev/null || echo "No debug output available"
                fi
                COUNT=$((COUNT + 1))
                sleep $RETRY_DELAY
            done
          fi

          if [ $COUNT -eq $MAX_RETRIES ]; then
            echo "‚ö†Ô∏è  SSH connection verification failed after $MAX_RETRIES attempts."
            echo "VM IP: ${{ env.VM_IP }}"
            echo "VM State: $(az vm show -d --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query powerState -o tsv 2>/dev/null || echo 'unknown')"
            echo ""
            echo "‚ö†Ô∏è  Warning: SSH connection failed. Deployment will continue, but manual intervention may be required."
            echo "To fix SSH access:"
            echo "1. Check if SSH key was added: az vm show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query 'osProfile.linuxConfiguration.ssh.publicKeys'"
            echo "2. Try adding SSH key manually: az vm user update --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --username ${{ env.VM_ADMIN_USERNAME }} --ssh-key-value \"<public-key>\""
            echo "3. Or use Azure Portal to reset SSH key"
            echo ""
            echo "‚ö†Ô∏è  Continuing deployment despite SSH failure..."
          else
            echo "‚úÖ SSH connection verified successfully!"
          fi

      - name: Check if Repository Exists on VM
        timeout-minutes: 2
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          CHECK_SCRIPT='if [ -d "/home/azureuser/SmartWatts" ] || [ -d "/home/azureuser/smartwatts" ]; then echo "EXISTS"; else echo "NOT_FOUND"; fi'
          REPO_STATUS=$(ssh -o StrictHostKeyChecking=no \
                         -o UserKnownHostsFile=/dev/null \
                         -o ConnectTimeout=15 \
                         -i ~/.ssh/id_rsa \
                         azureuser@$VM_IP "$CHECK_SCRIPT" 2>/dev/null || echo "NOT_FOUND")
          echo "REPO_STATUS=$REPO_STATUS" >> $GITHUB_ENV
          if [ "$REPO_STATUS" = "EXISTS" ]; then
            echo "‚úÖ Repository already exists on VM, skipping copy/extract steps"
          else
            if [ "$REPO_STATUS" = "NOT_FOUND" ]; then
              echo "‚ö†Ô∏è  Could not verify repository status (SSH may have failed). Assuming repository needs to be copied."
              echo "REPO_STATUS=NOT_FOUND" >> $GITHUB_ENV
            else
              echo "üì¶ Repository not found, will copy and extract"
            fi
          fi

      - name: Copy Repository to VM
        timeout-minutes: 5
        if: env.REPO_STATUS != 'EXISTS'
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=5
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Copying repository to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            if scp -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null \
                   -o ConnectTimeout=15 \
                   -i ~/.ssh/id_rsa \
                   -r ./* azureuser@$VM_IP:/tmp/smartwatts.tar.gz; then
              echo "Repository copied successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Copy failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "Error: Failed to copy repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Extract repository on VM
        timeout-minutes: 5
        if: env.REPO_STATUS != 'EXISTS'
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Extracting repository on VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            EXTRACT_SCRIPT=$(printf 'cd /home/azureuser\nif [ -d "smartwatts" ]; then\n  rm -rf smartwatts\nfi\nmkdir -p smartwatts\ncd smartwatts\ntar xzf /tmp/smartwatts.tar.gz\nrm /tmp/smartwatts.tar.gz\necho "Repository extracted successfully"')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=15 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$EXTRACT_SCRIPT"; then
              echo "Repository extracted successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Extraction failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "Error: Failed to extract repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Deploy Application to VM
        timeout-minutes: 30
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Deploying application to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            DEPLOY_SCRIPT=$(printf '%s\n' \
              'if ! command -v docker &> /dev/null; then' \
              '  echo "Installing Docker...";' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq ca-certificates curl gnupg lsb-release || true;' \
              '  sudo mkdir -p /etc/apt/keyrings;' \
              '  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg;' \
              '  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null;' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {' \
              '    echo "Docker CE installation failed, trying docker.io...";' \
              '    sudo apt-get install -y -qq docker.io docker-compose || { echo "Error: Docker installation failed"; exit 1; };' \
              '  };' \
              '  if ! command -v docker &> /dev/null; then' \
              '    echo "Error: Docker installation failed - docker command not found";' \
              '    exit 1;' \
              '  fi;' \
              '  if getent group docker > /dev/null 2>&1; then sudo usermod -aG docker $USER; fi;' \
              '  echo "Docker installed successfully";' \
              'fi;' \
              'if systemctl list-unit-files | grep -q docker.service; then' \
              '  sudo systemctl start docker || true;' \
              '  sudo systemctl enable docker || true;' \
              'else' \
              '  if ! sudo docker info > /dev/null 2>&1; then' \
              '    echo "Warning: Docker service not found, but Docker may still work";' \
              '    sudo dockerd > /dev/null 2>&1 &;' \
              '    sleep 5;' \
              '  fi;' \
              'fi;' \
              'if ! sudo docker info > /dev/null 2>&1; then' \
              '  echo "Error: Docker daemon is not running";' \
              '  exit 1;' \
              'fi;' \
              'echo "Docker is installed and running";' \
              'if ! command -v docker-compose &> /dev/null && ! (command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1); then' \
              '  sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose;' \
              '  sudo chmod +x /usr/local/bin/docker-compose;' \
              'fi;' \
              'REPO_DIR="";' \
              'if [ -d "/home/azureuser/SmartWatts" ]; then' \
              '  REPO_DIR="/home/azureuser/SmartWatts";' \
              'elif [ -d "/home/azureuser/smartwatts" ]; then' \
              '  REPO_DIR="/home/azureuser/smartwatts";' \
              'else' \
              '  echo "Error: Repository not found. Expected /home/azureuser/SmartWatts or /home/azureuser/smartwatts";' \
              '  exit 1;' \
              'fi;' \
              'cd "$REPO_DIR";' \
              'echo "Using repository at: $REPO_DIR";' \
              'echo "Verifying Gradle wrapper files exist...";' \
              'MISSING_FILES=0;' \
              'for service_dir in backend/*-service backend/*-gateway backend/service-discovery; do' \
              '  if [ -d "$service_dir" ]; then' \
              '    if [ ! -f "$service_dir/gradle/wrapper/gradle-wrapper.jar" ]; then' \
              '      echo "ERROR: Missing gradle-wrapper.jar in $service_dir";' \
              '      MISSING_FILES=$((MISSING_FILES + 1));' \
              '    else' \
              '      echo "‚úì Found gradle-wrapper.jar in $service_dir";' \
              '    fi;' \
              '  fi;' \
              'done;' \
              'if [ $MISSING_FILES -gt 0 ]; then' \
              '  echo "ERROR: $MISSING_FILES service(s) missing gradle-wrapper.jar files";' \
              '  echo "Listing backend directory structure:";' \
              '  find backend -name "gradle-wrapper.jar" -type f || echo "No gradle-wrapper.jar files found";' \
              '  exit 1;' \
              'fi;' \
              'echo "All Gradle wrapper files verified successfully";' \
              'cd azure-deployment;' \
              'export POSTGRES_PASSWORD="${POSTGRES_PASSWORD:-SmartWatts2024!}";' \
              'sudo docker-compose -f docker-compose.azure.yml up -d --build;' \
              'echo "Application deployed successfully"')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=15 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$DEPLOY_SCRIPT"; then
              echo "Application deployed successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Deployment failed, retrying in $((RETRY_COUNT * 10)) seconds..."
                sleep $((RETRY_COUNT * 10))
              else
                echo "Error: Failed to deploy application after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Check if Static Web App exists
        id: swacheck
        continue-on-error: true
        run: |
          STATIC_APP_NAME="sw-staging-dashboard"
          if az staticwebapp show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name $STATIC_APP_NAME >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Static Web App found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Static Web App '$STATIC_APP_NAME' not found"
          fi
          
          if [ -z "${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}" ]; then
            echo "token_set=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Warning: AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING secret is not set"
          else
            echo "token_set=true" >> $GITHUB_OUTPUT
            echo "‚úÖ API token is set"
          fi

      - name: Deploy Frontend to Static Web Apps
        timeout-minutes: 10
        if: steps.swacheck.outputs.exists == 'true' && steps.swacheck.outputs.token_set == 'true'
        continue-on-error: true
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "frontend"
          output_location: ".next"
          skip_app_build: false
          skip_api_build: true

      - name: Get Deployment Outputs
        run: |
          echo "VM Public IP: ${{ env.VM_IP }}"
          echo "Static Web App URL: $(az staticwebapp show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-staging-dashboard \
            --query defaultHostname -o tsv 2>/dev/null || echo 'Not available')"

      - name: Health Check
        timeout-minutes: 5
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=10
          RETRY_COUNT=0
          WAIT_INTERVAL=10
          
          echo "Performing health checks..."
          echo "  - Backend API: http://$VM_IP:8080/api/v1/health"
          echo "  - Frontend: http://$VM_IP:3000"
          echo "  - Frontend (via Nginx): http://$VM_IP"
          echo "Note: If SSH deployment failed, the application may not be running yet."
          
          BACKEND_HEALTHY=false
          FRONTEND_HEALTHY=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo ""
            echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            
            # Check Backend API
            if [ "$BACKEND_HEALTHY" = "false" ]; then
              CURL_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" http://$VM_IP:8080/api/v1/health 2>&1 || echo "CURL_ERROR")
              BACKEND_STATUS=$(echo "$CURL_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
              
              if [ "$BACKEND_STATUS" = "200" ]; then
                echo "‚úÖ Backend API is healthy (HTTP 200)"
                BACKEND_HEALTHY=true
              else
                echo "‚ö†Ô∏è  Backend API not responding (HTTP $BACKEND_STATUS)"
              fi
            fi
            
            # Check Frontend (port 3000)
            if [ "$FRONTEND_HEALTHY" = "false" ]; then
              FRONTEND_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" http://$VM_IP:3000 2>&1 || echo "CURL_ERROR")
              FRONTEND_STATUS=$(echo "$FRONTEND_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
              
              if [ "$FRONTEND_STATUS" = "200" ] || [ "$FRONTEND_STATUS" = "301" ] || [ "$FRONTEND_STATUS" = "302" ]; then
                echo "‚úÖ Frontend is accessible on port 3000 (HTTP $FRONTEND_STATUS)"
                FRONTEND_HEALTHY=true
              else
                echo "‚ö†Ô∏è  Frontend not responding on port 3000 (HTTP $FRONTEND_STATUS)"
              fi
            fi
            
            # Check Frontend via Nginx (port 80)
            NGINX_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" http://$VM_IP 2>&1 || echo "CURL_ERROR")
            NGINX_STATUS=$(echo "$NGINX_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
            if [ "$NGINX_STATUS" = "200" ] || [ "$NGINX_STATUS" = "301" ] || [ "$NGINX_STATUS" = "302" ]; then
              echo "‚úÖ Frontend accessible via Nginx on port 80 (HTTP $NGINX_STATUS)"
            else
              echo "‚ö†Ô∏è  Nginx not responding on port 80 (HTTP $NGINX_STATUS)"
            fi
            
            if [ "$BACKEND_HEALTHY" = "true" ] && [ "$FRONTEND_HEALTHY" = "true" ]; then
              echo ""
              echo "‚úÖ All health checks passed!"
              echo "   Frontend: http://$VM_IP:3000 or http://$VM_IP"
              echo "   Backend API: http://$VM_IP:8080"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              if [ "$BACKEND_STATUS" = "000" ]; then
                echo "‚ö†Ô∏è  Health check failed (HTTP $BACKEND_STATUS) - Connection refused or service not running"
                if [ $RETRY_COUNT -eq 1 ]; then
                  echo "Diagnostics:"
                  echo "  - Checking if port 8080 is accessible..."
                  timeout 3 bash -c "echo > /dev/tcp/$VM_IP/8080" 2>/dev/null && echo "    ‚úÖ Port 8080 is open" || echo "    ‚ùå Port 8080 is not accessible"
                  echo "  - This may be normal if the application hasn't been deployed yet (SSH may have failed)"
                fi
              else
                echo "Health check failed, retrying in $WAIT_INTERVAL seconds..."
              fi
              
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $WAIT_INTERVAL
              else
                echo "‚ö†Ô∏è  Warning: Health checks failed after $MAX_RETRIES attempts"
                echo "   Backend API: HTTP $BACKEND_STATUS"
                echo "   Frontend: HTTP $FRONTEND_STATUS"
                echo ""
                echo "Possible reasons:"
                echo "  1. Application deployment failed (check SSH connection and deployment logs above)"
                echo "  2. Application is still starting up (may need more time)"
                echo "  3. Port 8080 is not accessible (check NSG rules and firewall)"
                echo "  4. Application crashed or failed to start"
                echo ""
                echo "‚ö†Ô∏è  Continuing workflow despite health check failure..."
                echo "You may need to manually check the VM and deploy the application."
                exit 0
              fi
            fi
          done

      - name: Post-Deployment Summary
        run: |
          echo "‚úÖ Deployment completed."
          echo "VM IP: ${{ env.VM_IP }}"
          echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "Deployment Name: main"
