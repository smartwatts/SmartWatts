name: Deploy Staging (main branch)

on:
  push:
    branches: [ "main" ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'infrastructure/**'
      - 'azure-deployment/**'
      - '.github/workflows/deploy-staging.yml'
      - '!docs/**'
      - '!*.md'
      - '!.github/workflows/*.md'
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-staging-rg
  ENVIRONMENT: staging
  LOCATION: centralus
  VM_NAME: sw-staging-vm
  VM_ADMIN_USERNAME: azureuser
  TEMPLATE_FILE: infrastructure/bicep/main.bicep
  PARAM_FILE: infrastructure/bicep/params.staging.json
  PUBLIC_IP_NAME: sw-staging-vm-pip

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_STAGING }}

      - name: Check and Recreate Resource Group
        timeout-minutes: 5
        run: |
          # Check if resource group exists
          if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            CURRENT_LOCATION=$(az group show --name ${{ env.AZURE_RESOURCE_GROUP }} --query location -o tsv)
            echo "Resource group exists in location: $CURRENT_LOCATION"
            
            # If location doesn't match, delete and recreate
            if [ "$CURRENT_LOCATION" != "${{ env.LOCATION }}" ]; then
              echo "‚ö†Ô∏è  Resource group is in $CURRENT_LOCATION, but we need ${{ env.LOCATION }}"
              echo "üóëÔ∏è  Deleting existing resource group to recreate in ${{ env.LOCATION }}..."
              az group delete --name ${{ env.AZURE_RESOURCE_GROUP }} --yes --no-wait
              echo "‚è≥ Waiting for deletion to complete (this may take a few minutes)..."
              
              # Wait for deletion (max 10 minutes)
              MAX_WAIT=600
              ELAPSED=0
              while az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null && [ $ELAPSED -lt $MAX_WAIT ]; do
                echo -n "."
                sleep 10
                ELAPSED=$((ELAPSED + 10))
              done
              echo ""
              
              if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
                echo "‚ùå Error: Resource group deletion timed out"
                echo "Please delete it manually: az group delete --name ${{ env.AZURE_RESOURCE_GROUP }} --yes"
                exit 1
              else
                echo "‚úÖ Resource group deleted successfully"
              fi
            else
              echo "‚úÖ Resource group is already in the correct location"
            fi
          fi
          
          # Create resource group if it doesn't exist
          if ! az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "üì¶ Creating resource group in ${{ env.LOCATION }}..."
            az group create \
              --name ${{ env.AZURE_RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }} \
              --output none
            echo "‚úÖ Resource group created"
          fi

      - name: Check if VM exists
        id: vmcheck
        run: |
          echo "Checking if ${{ env.VM_NAME }} exists in resource group ${{ env.AZURE_RESOURCE_GROUP }}"
          if az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "VM already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "VM does not exist - will be created"
          fi

      - name: Extract SSH public key from secret
        id: sshkey
        run: |
          set -e
          mkdir -p ~/.ssh
          SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_STAGING }}"
          
          # Write private key temporarily to extract public key
          if echo "$SSH_KEY" | head -c 20 | grep -q "BEGIN"; then
            echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
          else
            echo "$SSH_KEY" | base64 -d > ~/.ssh/temp_key
          fi
          chmod 600 ~/.ssh/temp_key
          
          # Convert key format if needed
          KEY_START=$(head -c 20 ~/.ssh/temp_key | xxd -p | tr -d '\n')
          if echo "$KEY_START" | grep -q "^3082"; then
            # DER format - convert to PEM
            openssl rsa -inform DER -in ~/.ssh/temp_key -outform PEM -out ~/.ssh/temp_key.pem 2>/dev/null && mv ~/.ssh/temp_key.pem ~/.ssh/temp_key || {
              ssh-keygen -p -N "" -m PEM -f ~/.ssh/temp_key > /dev/null 2>&1 || true
            }
          elif head -c 15 ~/.ssh/temp_key | grep -q "openssh-key-v1"; then
            # OpenSSH format - convert to PEM
            ssh-keygen -p -N "" -m PEM -f ~/.ssh/temp_key > /dev/null 2>&1 || true
          fi
          
          # Extract public key
          SSH_PUBLIC_KEY=$(ssh-keygen -y -f ~/.ssh/temp_key 2>/dev/null || echo "")
          rm -f ~/.ssh/temp_key
          
          if [ -z "$SSH_PUBLIC_KEY" ]; then
            echo "‚ö†Ô∏è Warning: Could not extract SSH public key from private key"
            echo "VM will be created without SSH keys (password authentication only)"
            echo "public_key=" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ SSH public key extracted successfully"
            echo "public_key=$SSH_PUBLIC_KEY" >> $GITHUB_OUTPUT
            # Also save to file for later use
            echo "$SSH_PUBLIC_KEY" > ~/.ssh/id_rsa.pub
            cp ~/.ssh/temp_key ~/.ssh/id_rsa 2>/dev/null || true
          fi
          
          # Save private key for SSH connection
          if [ -n "$SSH_KEY" ]; then
            if echo "$SSH_KEY" | head -c 20 | grep -q "BEGIN"; then
              echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/id_rsa
            else
              echo "$SSH_KEY" | base64 -d > ~/.ssh/id_rsa
            fi
            chmod 600 ~/.ssh/id_rsa
          fi

      - name: Check if Key Vault exists
        id: kvcheck
        run: |
          # Key Vault names are globally unique, so check across all resource groups
          # First try to find it in any resource group
          KV_EXISTS=$(az keyvault list --query "[?name=='sw-staging-kv'] | length(@)" -o tsv 2>/dev/null || echo "0")
          
          # Also check for soft-deleted Key Vaults
          KV_DELETED=$(az keyvault list-deleted --query "[?name=='sw-staging-kv'] | length(@)" -o tsv 2>/dev/null || echo "0")
          
          if [ "$KV_EXISTS" != "0" ] || [ "$KV_DELETED" != "0" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            if [ "$KV_DELETED" != "0" ]; then
              echo "‚ö†Ô∏è  Key Vault exists in soft-deleted state - will not create"
            else
              echo "‚úÖ Key Vault already exists globally"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "üì¶ Key Vault does not exist - will be created"
          fi

      - name: Deploy Infrastructure via Bicep
        id: deploy
        timeout-minutes: 20
        run: |
          set -e
          DEPLOY_CMD="az deployment group create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name main \
            --template-file ${{ env.TEMPLATE_FILE }} \
            --parameters @${{ env.PARAM_FILE }} \
            --parameters vmAdminPassword=\"${{ secrets.VM_ADMIN_PASSWORD_STAGING }}\" \
            --parameters createKeyVault=$([ "${{ steps.kvcheck.outputs.exists }}" = "true" ] && echo "false" || echo "true") \
            --mode Incremental"

          # Only pass SSH key if VM doesn't already exist
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ] && [ -n "${{ steps.sshkey.outputs.public_key }}" ]; then
            echo "VM not found. Injecting SSH key for initial creation."
            DEPLOY_CMD="$DEPLOY_CMD --parameters vmSshPublicKey=\"${{ steps.sshkey.outputs.public_key }}\""
          else
            if [ "${{ steps.vmcheck.outputs.exists }}" = "true" ]; then
              echo "VM already exists. Skipping vmSshPublicKey parameter (Azure doesn't allow updating SSH keys via Bicep)."
            else
              echo "No SSH public key available. VM will be created without SSH keys."
            fi
          fi

          echo "Running deployment command..."
          eval "$DEPLOY_CMD"

      - name: Retrieve VM Public IP
        id: get_ip
        run: |
          VM_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.PUBLIC_IP_NAME }} \
            --query "ipAddress" -o tsv)
          echo "VM_IP=$VM_IP" >> $GITHUB_ENV
          echo "VM IP: $VM_IP"

      - name: Update VM SSH key (if VM already existed)
        if: steps.vmcheck.outputs.exists == 'true' && steps.sshkey.outputs.public_key != ''
        run: |
          echo "Updating VM authorized_keys using Azure CLI..."
          if az vm user update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --username ${{ env.VM_ADMIN_USERNAME }} \
            --ssh-key-value "${{ steps.sshkey.outputs.public_key }}" 2>&1; then
            echo "‚úÖ SSH key updated successfully"
            echo "Waiting 30 seconds for key to propagate..."
            sleep 30
          else
            echo "‚ö†Ô∏è Warning: Failed to update SSH key via Azure CLI"
            echo "You may need to manually add the SSH key or recreate the VM"
          fi

      - name: Verify SSH Connection
        timeout-minutes: 5
        continue-on-error: true
        run: |
          MAX_RETRIES=5
          RETRY_DELAY=15
          COUNT=0

          echo "Verifying SSH connection to ${{ env.VM_IP }}..."
          
          # Check NSG rules
          echo "Checking NSG rules for SSH access..."
          NSG_NAME=$(az network nsg list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[?contains(name, 'nsg')].name" -o tsv | head -1)
          if [ -n "$NSG_NAME" ]; then
            echo "NSG: $NSG_NAME"
            az network nsg rule list --nsg-name "$NSG_NAME" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[?destinationPortRange=='22']" -o table || echo "Could not list NSG rules"
          fi
          
          # Check if SSH service is accessible
          echo "Testing SSH port connectivity..."
          timeout 5 bash -c "echo > /dev/tcp/${{ env.VM_IP }}/22" 2>/dev/null && echo "‚úÖ Port 22 is open" || echo "‚ö†Ô∏è  Port 22 may be blocked or SSH service not running"
          
          # Add VM to known_hosts (non-blocking)
          ssh-keyscan -H ${{ env.VM_IP }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add VM to known_hosts (will continue)"

          # Verify SSH key file exists
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ö†Ô∏è  Warning: SSH private key file not found at ~/.ssh/id_rsa"
            echo "SSH connection will likely fail. Continuing anyway..."
          else
            echo "‚úÖ SSH private key file found"
            # Test SSH connection with verbose output for first attempt
            until ssh -i ~/.ssh/id_rsa \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=/dev/null \
              -o ConnectTimeout=10 \
              -o BatchMode=yes \
              -v ${{ env.VM_ADMIN_USERNAME }}@${{ env.VM_IP }} 'echo "SSH connection successful"' 2>&1 | tee /tmp/ssh_debug.log \
              || [ $COUNT -eq $MAX_RETRIES ]; do
                echo "Attempt $((COUNT + 1)) of $MAX_RETRIES failed. Retrying in $RETRY_DELAY seconds..."
                if [ $COUNT -eq 0 ]; then
                  echo "First attempt SSH debug output:"
                  tail -20 /tmp/ssh_debug.log 2>/dev/null || echo "No debug output available"
                fi
                COUNT=$((COUNT + 1))
                sleep $RETRY_DELAY
            done
          fi

          if [ $COUNT -eq $MAX_RETRIES ]; then
            echo "‚ö†Ô∏è  SSH connection verification failed after $MAX_RETRIES attempts."
            echo "VM IP: ${{ env.VM_IP }}"
            echo "VM State: $(az vm show -d --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query powerState -o tsv 2>/dev/null || echo 'unknown')"
            echo ""
            echo "‚ö†Ô∏è  Warning: SSH connection failed. Deployment will continue, but manual intervention may be required."
            echo "To fix SSH access:"
            echo "1. Check if SSH key was added: az vm show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query 'osProfile.linuxConfiguration.ssh.publicKeys'"
            echo "2. Try adding SSH key manually: az vm user update --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --username ${{ env.VM_ADMIN_USERNAME }} --ssh-key-value \"<public-key>\""
            echo "3. Or use Azure Portal to reset SSH key"
            echo ""
            echo "‚ö†Ô∏è  Continuing deployment despite SSH failure..."
          else
            echo "‚úÖ SSH connection verified successfully!"
          fi

      - name: Check if Repository Exists on VM
        timeout-minutes: 2
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          CHECK_SCRIPT='if [ -d "/home/azureuser/SmartWatts" ] || [ -d "/home/azureuser/smartwatts" ]; then echo "EXISTS"; else echo "NOT_FOUND"; fi'
          REPO_STATUS=$(ssh -o StrictHostKeyChecking=no \
                         -o UserKnownHostsFile=/dev/null \
                         -o ConnectTimeout=15 \
                         -i ~/.ssh/id_rsa \
                         azureuser@$VM_IP "$CHECK_SCRIPT" 2>/dev/null || echo "NOT_FOUND")
          echo "REPO_STATUS=$REPO_STATUS" >> $GITHUB_ENV
          if [ "$REPO_STATUS" = "EXISTS" ]; then
            echo "‚úÖ Repository already exists on VM, skipping copy/extract steps"
          else
            if [ "$REPO_STATUS" = "NOT_FOUND" ]; then
              echo "‚ö†Ô∏è  Could not verify repository status (SSH may have failed). Assuming repository needs to be copied."
              echo "REPO_STATUS=NOT_FOUND" >> $GITHUB_ENV
            else
              echo "üì¶ Repository not found, will copy and extract"
            fi
          fi

      - name: Copy Repository to VM
        timeout-minutes: 5
        if: env.REPO_STATUS != 'EXISTS'
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=5
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Copying repository to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            if scp -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null \
                   -o ConnectTimeout=15 \
                   -i ~/.ssh/id_rsa \
                   -r ./* azureuser@$VM_IP:/tmp/smartwatts.tar.gz; then
              echo "Repository copied successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Copy failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "Error: Failed to copy repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Extract repository on VM
        timeout-minutes: 5
        if: env.REPO_STATUS != 'EXISTS'
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Extracting repository on VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            EXTRACT_SCRIPT=$(printf 'cd /home/azureuser\nif [ -d "smartwatts" ]; then\n  rm -rf smartwatts\nfi\nmkdir -p smartwatts\ncd smartwatts\ntar xzf /tmp/smartwatts.tar.gz\nrm /tmp/smartwatts.tar.gz\necho "Repository extracted successfully"')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=15 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$EXTRACT_SCRIPT"; then
              echo "Repository extracted successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Extraction failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "Error: Failed to extract repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Deploy Application to VM
        timeout-minutes: 30
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Deploying application to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            DEPLOY_SCRIPT=$(printf '%s\n' \
              'if ! command -v docker &> /dev/null; then' \
              '  echo "Installing Docker...";' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq ca-certificates curl gnupg lsb-release || true;' \
              '  sudo mkdir -p /etc/apt/keyrings;' \
              '  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg;' \
              '  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null;' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {' \
              '    echo "Docker CE installation failed, trying docker.io...";' \
              '    sudo apt-get install -y -qq docker.io docker-compose || { echo "Error: Docker installation failed"; exit 1; };' \
              '  };' \
              '  if ! command -v docker &> /dev/null; then' \
              '    echo "Error: Docker installation failed - docker command not found";' \
              '    exit 1;' \
              '  fi;' \
              '  if getent group docker > /dev/null 2>&1; then sudo usermod -aG docker $USER; fi;' \
              '  echo "Docker installed successfully";' \
              'fi;' \
              'if systemctl list-unit-files | grep -q docker.service; then' \
              '  sudo systemctl start docker || true;' \
              '  sudo systemctl enable docker || true;' \
              'else' \
              '  if ! sudo docker info > /dev/null 2>&1; then' \
              '    echo "Warning: Docker service not found, but Docker may still work";' \
              '    sudo dockerd > /dev/null 2>&1 &;' \
              '    sleep 5;' \
              '  fi;' \
              'fi;' \
              'if ! sudo docker info > /dev/null 2>&1; then' \
              '  echo "Error: Docker daemon is not running";' \
              '  exit 1;' \
              'fi;' \
              'echo "Docker is installed and running";' \
              'if ! command -v docker-compose &> /dev/null && ! (command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1); then' \
              '  sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose;' \
              '  sudo chmod +x /usr/local/bin/docker-compose;' \
              'fi;' \
              'REPO_DIR="";' \
              'if [ -d "/home/azureuser/SmartWatts" ]; then' \
              '  REPO_DIR="/home/azureuser/SmartWatts";' \
              'elif [ -d "/home/azureuser/smartwatts" ]; then' \
              '  REPO_DIR="/home/azureuser/smartwatts";' \
              'else' \
              '  echo "Error: Repository not found. Expected /home/azureuser/SmartWatts or /home/azureuser/smartwatts";' \
              '  exit 1;' \
              'fi;' \
              'cd "$REPO_DIR";' \
              'echo "Using repository at: $REPO_DIR";' \
              'echo "Verifying Gradle wrapper files exist...";' \
              'MISSING_FILES=0;' \
              'for service_dir in backend/*-service backend/*-gateway backend/service-discovery; do' \
              '  if [ -d "$service_dir" ]; then' \
              '    if [ ! -f "$service_dir/gradle/wrapper/gradle-wrapper.jar" ]; then' \
              '      echo "ERROR: Missing gradle-wrapper.jar in $service_dir";' \
              '      MISSING_FILES=$((MISSING_FILES + 1));' \
              '    else' \
              '      echo "‚úì Found gradle-wrapper.jar in $service_dir";' \
              '    fi;' \
              '  fi;' \
              'done;' \
              'if [ $MISSING_FILES -gt 0 ]; then' \
              '  echo "ERROR: $MISSING_FILES service(s) missing gradle-wrapper.jar files";' \
              '  echo "Listing backend directory structure:";' \
              '  find backend -name "gradle-wrapper.jar" -type f || echo "No gradle-wrapper.jar files found";' \
              '  exit 1;' \
              'fi;' \
              'echo "All Gradle wrapper files verified successfully";' \
              'cd azure-deployment;' \
              'export POSTGRES_PASSWORD="${POSTGRES_PASSWORD:-SmartWatts2024!}";' \
              'sudo docker-compose -f docker-compose.azure.yml up -d --build;' \
              'echo "Application deployed successfully"')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=15 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$DEPLOY_SCRIPT"; then
              echo "Application deployed successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Deployment failed, retrying in $((RETRY_COUNT * 10)) seconds..."
                sleep $((RETRY_COUNT * 10))
              else
                echo "Error: Failed to deploy application after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Deploy Frontend to Static Web Apps
        timeout-minutes: 10
        continue-on-error: true
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "frontend"
          output_location: ".next"
          skip_app_build: false
          skip_api_build: true

      - name: Get Deployment Outputs
        run: |
          echo "VM Public IP: ${{ env.VM_IP }}"
          echo "Static Web App URL: $(az staticwebapp show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-staging-dashboard \
            --query defaultHostname -o tsv 2>/dev/null || echo 'Not available')"

      - name: Health Check
        timeout-minutes: 5
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=10
          RETRY_COUNT=0
          WAIT_INTERVAL=10
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Performing health check (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$VM_IP:8080/api/v1/health || echo "000")
            
            if [ "$HEALTH_STATUS" = "200" ]; then
              echo "‚úÖ Backend API is healthy (HTTP 200)"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Health check failed (HTTP $HEALTH_STATUS), retrying in $WAIT_INTERVAL seconds..."
                sleep $WAIT_INTERVAL
              else
                echo "‚ùå Error: Backend API health check failed after $MAX_RETRIES attempts (HTTP $HEALTH_STATUS)"
                exit 1
              fi
            fi
          done
          
          echo "All health checks passed."

      - name: Post-Deployment Summary
        run: |
          echo "‚úÖ Deployment completed."
          echo "VM IP: ${{ env.VM_IP }}"
          echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "Deployment Name: main"
