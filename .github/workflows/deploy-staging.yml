name: Deploy Staging (main branch)

on:
  push:
    branches: [ "main" ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'infrastructure/**'
      - 'azure-deployment/**'
      - '.github/workflows/deploy-staging.yml'
      - '!docs/**'
      - '!*.md'
      - '!.github/workflows/*.md'
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-staging-rg
  ENVIRONMENT: staging
  LOCATION: ukwest
  VM_NAME: sw-staging-vm
  VM_ADMIN_USERNAME: azureuser
  TEMPLATE_FILE: infrastructure/bicep/main.bicep
  PARAM_FILE: infrastructure/bicep/params.staging.json
  PUBLIC_IP_NAME: sw-staging-vm-pip

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_STAGING }}

      - name: Create Resource Group
        timeout-minutes: 2
        run: |
          # Check if resource group exists, create if it doesn't
          if ! az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "Creating resource group..."
            az group create \
              --name ${{ env.AZURE_RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }} \
              --output none
          else
            echo "Resource group already exists"
          fi

      - name: Check if VM exists
        id: vmcheck
        run: |
          echo "Checking if ${{ env.VM_NAME }} exists in resource group ${{ env.AZURE_RESOURCE_GROUP }}"
          if az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "VM already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "VM does not exist - will be created"
          fi

      - name: Extract SSH public key from secret
        id: sshkey
        run: |
          set -e
          mkdir -p ~/.ssh
          SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_STAGING }}"
          
          # Write private key temporarily to extract public key
          if echo "$SSH_KEY" | head -c 20 | grep -q "BEGIN"; then
            echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
          else
            echo "$SSH_KEY" | base64 -d > ~/.ssh/temp_key
          fi
          chmod 600 ~/.ssh/temp_key
          
          # Convert key format if needed
          KEY_START=$(head -c 20 ~/.ssh/temp_key | xxd -p | tr -d '\n')
          if echo "$KEY_START" | grep -q "^3082"; then
            # DER format - convert to PEM
            openssl rsa -inform DER -in ~/.ssh/temp_key -outform PEM -out ~/.ssh/temp_key.pem 2>/dev/null && mv ~/.ssh/temp_key.pem ~/.ssh/temp_key || {
              ssh-keygen -p -N "" -m PEM -f ~/.ssh/temp_key > /dev/null 2>&1 || true
            }
          elif head -c 15 ~/.ssh/temp_key | grep -q "openssh-key-v1"; then
            # OpenSSH format - convert to PEM
            ssh-keygen -p -N "" -m PEM -f ~/.ssh/temp_key > /dev/null 2>&1 || true
          fi
          
          # Extract public key
          SSH_PUBLIC_KEY=$(ssh-keygen -y -f ~/.ssh/temp_key 2>/dev/null || echo "")
          rm -f ~/.ssh/temp_key
          
          if [ -z "$SSH_PUBLIC_KEY" ]; then
            echo "⚠️ Warning: Could not extract SSH public key from private key"
            echo "VM will be created without SSH keys (password authentication only)"
            echo "public_key=" >> $GITHUB_OUTPUT
          else
            echo "✅ SSH public key extracted successfully"
            echo "public_key=$SSH_PUBLIC_KEY" >> $GITHUB_OUTPUT
            # Also save to file for later use
            echo "$SSH_PUBLIC_KEY" > ~/.ssh/id_rsa.pub
            cp ~/.ssh/temp_key ~/.ssh/id_rsa 2>/dev/null || true
          fi
          
          # Save private key for SSH connection
          if [ -n "$SSH_KEY" ]; then
            if echo "$SSH_KEY" | head -c 20 | grep -q "BEGIN"; then
              echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/id_rsa
            else
              echo "$SSH_KEY" | base64 -d > ~/.ssh/id_rsa
            fi
            chmod 600 ~/.ssh/id_rsa
          fi

      - name: Deploy Infrastructure via Bicep
        id: deploy
        timeout-minutes: 20
        run: |
          set -e
          DEPLOY_CMD="az deployment group create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name main \
            --template-file ${{ env.TEMPLATE_FILE }} \
            --parameters @${{ env.PARAM_FILE }} \
            --parameters vmAdminPassword=\"${{ secrets.VM_ADMIN_PASSWORD_STAGING }}\" \
            --mode Incremental"

          # Only pass SSH key if VM doesn't already exist
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ] && [ -n "${{ steps.sshkey.outputs.public_key }}" ]; then
            echo "VM not found. Injecting SSH key for initial creation."
            DEPLOY_CMD="$DEPLOY_CMD --parameters vmSshPublicKey=\"${{ steps.sshkey.outputs.public_key }}\""
          else
            if [ "${{ steps.vmcheck.outputs.exists }}" = "true" ]; then
              echo "VM already exists. Skipping vmSshPublicKey parameter (Azure doesn't allow updating SSH keys via Bicep)."
            else
              echo "No SSH public key available. VM will be created without SSH keys."
            fi
          fi

          echo "Running deployment command..."
          eval "$DEPLOY_CMD"

      - name: Retrieve VM Public IP
        id: get_ip
        run: |
          VM_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.PUBLIC_IP_NAME }} \
            --query "ipAddress" -o tsv)
          echo "VM_IP=$VM_IP" >> $GITHUB_ENV
          echo "VM IP: $VM_IP"

      - name: Update VM SSH key (if VM already existed)
        if: steps.vmcheck.outputs.exists == 'true' && steps.sshkey.outputs.public_key != ''
        run: |
          echo "Updating VM authorized_keys using Azure CLI..."
          if az vm user update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --username ${{ env.VM_ADMIN_USERNAME }} \
            --ssh-key-value "${{ steps.sshkey.outputs.public_key }}" 2>&1; then
            echo "✅ SSH key updated successfully"
            echo "Waiting 30 seconds for key to propagate..."
            sleep 30
          else
            echo "⚠️ Warning: Failed to update SSH key via Azure CLI"
            echo "You may need to manually add the SSH key or recreate the VM"
          fi

      - name: Verify SSH Connection
        timeout-minutes: 5
        run: |
          set -e
          MAX_RETRIES=5
          RETRY_DELAY=15
          COUNT=0

          echo "Verifying SSH connection to ${{ env.VM_IP }}..."
          
          # Add VM to known_hosts (non-blocking)
          ssh-keyscan -H ${{ env.VM_IP }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add VM to known_hosts (will continue)"

          until ssh -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            -o BatchMode=yes \
            ${{ env.VM_ADMIN_USERNAME }}@${{ env.VM_IP }} 'echo "SSH connection successful"' 2>/dev/null \
            || [ $COUNT -eq $MAX_RETRIES ]; do
              echo "Attempt $((COUNT + 1)) of $MAX_RETRIES failed. Retrying in $RETRY_DELAY seconds..."
              COUNT=$((COUNT + 1))
              sleep $RETRY_DELAY
          done

          if [ $COUNT -eq $MAX_RETRIES ]; then
            echo "❌ SSH connection verification failed after $MAX_RETRIES attempts."
            echo "VM IP: ${{ env.VM_IP }}"
            echo "VM State: $(az vm show -d --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query powerState -o tsv 2>/dev/null || echo 'unknown')"
            echo ""
            echo "The SSH key should be configured on the VM."
            echo "If this error persists, check that the SSH key was added correctly."
            exit 1
          fi
          
          echo "✅ SSH connection verified successfully!"

      - name: Copy Repository to VM
        timeout-minutes: 5
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=5
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Copying repository to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            if scp -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null \
                   -o ConnectTimeout=15 \
                   -i ~/.ssh/id_rsa \
                   -r ./* azureuser@$VM_IP:/tmp/smartwatts.tar.gz; then
              echo "Repository copied successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Copy failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "Error: Failed to copy repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Extract repository on VM
        timeout-minutes: 5
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Extracting repository on VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            EXTRACT_SCRIPT=$(printf 'cd /home/azureuser\nif [ -d "smartwatts" ]; then\n  rm -rf smartwatts\nfi\nmkdir -p smartwatts\ncd smartwatts\ntar xzf /tmp/smartwatts.tar.gz\nrm /tmp/smartwatts.tar.gz\necho "Repository extracted successfully"')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=15 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$EXTRACT_SCRIPT"; then
              echo "Repository extracted successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Extraction failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "Error: Failed to extract repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Deploy Application to VM
        timeout-minutes: 30
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Deploying application to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            DEPLOY_SCRIPT=$(printf '%s\n' \
              'if ! command -v docker &> /dev/null; then' \
              '  echo "Installing Docker...";' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq ca-certificates curl gnupg lsb-release || true;' \
              '  sudo mkdir -p /etc/apt/keyrings;' \
              '  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg;' \
              '  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null;' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {' \
              '    echo "Docker CE installation failed, trying docker.io...";' \
              '    sudo apt-get install -y -qq docker.io docker-compose || { echo "Error: Docker installation failed"; exit 1; };' \
              '  };' \
              '  if ! command -v docker &> /dev/null; then' \
              '    echo "Error: Docker installation failed - docker command not found";' \
              '    exit 1;' \
              '  fi;' \
              '  if getent group docker > /dev/null 2>&1; then sudo usermod -aG docker $USER; fi;' \
              '  echo "Docker installed successfully";' \
              'fi;' \
              'if systemctl list-unit-files | grep -q docker.service; then' \
              '  sudo systemctl start docker || true;' \
              '  sudo systemctl enable docker || true;' \
              'else' \
              '  if ! sudo docker info > /dev/null 2>&1; then' \
              '    echo "Warning: Docker service not found, but Docker may still work";' \
              '    sudo dockerd > /dev/null 2>&1 &;' \
              '    sleep 5;' \
              '  fi;' \
              'fi;' \
              'if ! sudo docker info > /dev/null 2>&1; then' \
              '  echo "Error: Docker daemon is not running";' \
              '  exit 1;' \
              'fi;' \
              'echo "Docker is installed and running";' \
              'if ! command -v docker-compose &> /dev/null && ! (command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1); then' \
              '  sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose;' \
              '  sudo chmod +x /usr/local/bin/docker-compose;' \
              'fi;' \
              'cd /home/azureuser/smartwatts;' \
              'echo "Verifying Gradle wrapper files exist...";' \
              'MISSING_FILES=0;' \
              'for service_dir in backend/*-service backend/*-gateway backend/service-discovery; do' \
              '  if [ -d "$service_dir" ]; then' \
              '    if [ ! -f "$service_dir/gradle/wrapper/gradle-wrapper.jar" ]; then' \
              '      echo "ERROR: Missing gradle-wrapper.jar in $service_dir";' \
              '      MISSING_FILES=$((MISSING_FILES + 1));' \
              '    else' \
              '      echo "✓ Found gradle-wrapper.jar in $service_dir";' \
              '    fi;' \
              '  fi;' \
              'done;' \
              'if [ $MISSING_FILES -gt 0 ]; then' \
              '  echo "ERROR: $MISSING_FILES service(s) missing gradle-wrapper.jar files";' \
              '  echo "Listing backend directory structure:";' \
              '  find backend -name "gradle-wrapper.jar" -type f || echo "No gradle-wrapper.jar files found";' \
              '  exit 1;' \
              'fi;' \
              'echo "All Gradle wrapper files verified successfully";' \
              'cd azure-deployment;' \
              'sudo docker-compose -f docker-compose.azure.yml up -d --build;' \
              'echo "Application deployed successfully"')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=15 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$DEPLOY_SCRIPT"; then
              echo "Application deployed successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Deployment failed, retrying in $((RETRY_COUNT * 10)) seconds..."
                sleep $((RETRY_COUNT * 10))
              else
                echo "Error: Failed to deploy application after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Deploy Frontend to Static Web Apps
        timeout-minutes: 10
        continue-on-error: true
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "frontend"
          output_location: ".next"
          skip_app_build: false
          skip_api_build: true

      - name: Get Deployment Outputs
        run: |
          echo "VM Public IP: ${{ env.VM_IP }}"
          echo "Static Web App URL: $(az staticwebapp show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-staging-dashboard \
            --query defaultHostname -o tsv 2>/dev/null || echo 'Not available')"

      - name: Health Check
        timeout-minutes: 5
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=10
          RETRY_COUNT=0
          WAIT_INTERVAL=10
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Performing health check (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$VM_IP:8080/api/v1/health || echo "000")
            
            if [ "$HEALTH_STATUS" = "200" ]; then
              echo "✅ Backend API is healthy (HTTP 200)"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Health check failed (HTTP $HEALTH_STATUS), retrying in $WAIT_INTERVAL seconds..."
                sleep $WAIT_INTERVAL
              else
                echo "❌ Error: Backend API health check failed after $MAX_RETRIES attempts (HTTP $HEALTH_STATUS)"
                exit 1
              fi
            fi
          done
          
          echo "All health checks passed."

      - name: Post-Deployment Summary
        run: |
          echo "✅ Deployment completed."
          echo "VM IP: ${{ env.VM_IP }}"
          echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "Deployment Name: main"
