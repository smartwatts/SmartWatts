name: Deploy Staging (main branch)

on:
  push:
    branches: [ "main" ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'infrastructure/**'
      - 'azure-deployment/**'
      - '.github/workflows/deploy-staging.yml'
      - '!docs/**'
      - '!*.md'
      - '!.github/workflows/*.md'
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-staging-rg
  ENVIRONMENT: staging
  LOCATION: centralus
  VM_NAME: sw-staging-vm
  VM_ADMIN_USERNAME: azureuser
  TEMPLATE_FILE: infrastructure/bicep/main.bicep
  PARAM_FILE: infrastructure/bicep/params.staging.json
  PUBLIC_IP_NAME: sw-staging-vm-pip

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_STAGING }}

      - name: Check and Recreate Resource Group
        timeout-minutes: 5
        run: |
          # Check if resource group exists
          if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            CURRENT_LOCATION=$(az group show --name ${{ env.AZURE_RESOURCE_GROUP }} --query location -o tsv)
            echo "Resource group exists in location: $CURRENT_LOCATION"
            
            # If location doesn't match, delete and recreate
            if [ "$CURRENT_LOCATION" != "${{ env.LOCATION }}" ]; then
              echo "‚ö†Ô∏è  Resource group is in $CURRENT_LOCATION, but we need ${{ env.LOCATION }}"
              echo "üóëÔ∏è  Deleting existing resource group to recreate in ${{ env.LOCATION }}..."
              az group delete --name ${{ env.AZURE_RESOURCE_GROUP }} --yes --no-wait
              echo "‚è≥ Waiting for deletion to complete (this may take a few minutes)..."
              
              # Wait for deletion (max 10 minutes)
              MAX_WAIT=600
              ELAPSED=0
              while az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null && [ $ELAPSED -lt $MAX_WAIT ]; do
                echo -n "."
                sleep 10
                ELAPSED=$((ELAPSED + 10))
              done
              echo ""
              
              if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
                echo "‚ùå Error: Resource group deletion timed out"
                echo "Please delete it manually: az group delete --name ${{ env.AZURE_RESOURCE_GROUP }} --yes"
                exit 1
              else
                echo "‚úÖ Resource group deleted successfully"
              fi
            else
              echo "‚úÖ Resource group is already in the correct location"
            fi
          fi
          
          # Create resource group if it doesn't exist
          if ! az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "üì¶ Creating resource group in ${{ env.LOCATION }}..."
            az group create \
              --name ${{ env.AZURE_RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }} \
              --output none
            echo "‚úÖ Resource group created"
          fi

      - name: Check if VM exists
        id: vmcheck
        run: |
          echo "Checking if ${{ env.VM_NAME }} exists in resource group ${{ env.AZURE_RESOURCE_GROUP }}"
          if az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "VM already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "VM does not exist - will be created"
          fi

      - name: Check if VM has SSH keys configured
        id: vmsshcheck
        if: steps.vmcheck.outputs.exists == 'true'
        run: |
          echo "Checking if existing VM has SSH keys configured..."
          SSH_KEYS=$(az vm show \
            --name ${{ env.VM_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "osProfile.linuxConfiguration.ssh.publicKeys" \
            -o json 2>/dev/null || echo "[]")
          
          # Check if SSH keys array is empty or null
          if [ "$SSH_KEYS" = "[]" ] || [ "$SSH_KEYS" = "null" ] || [ -z "$SSH_KEYS" ]; then
            echo "has_ssh_keys=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  VM exists but has no SSH keys configured"
            echo "This VM was likely created incorrectly and needs to be recreated"
          else
            echo "has_ssh_keys=true" >> $GITHUB_OUTPUT
            echo "‚úÖ VM has SSH keys configured"
            echo "SSH keys: $SSH_KEYS"
          fi

      - name: Test SSH Connectivity (Health Check)
        id: sshhealthcheck
        if: steps.vmcheck.outputs.exists == 'true' && steps.vmsshcheck.outputs.has_ssh_keys == 'true'
        timeout-minutes: 3
        continue-on-error: true
        run: |
          echo "Testing SSH connectivity to verify VM is actually accessible..."
          
          # Get VM IP
          VM_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.PUBLIC_IP_NAME }} \
            --query "ipAddress" -o tsv 2>/dev/null || echo "")
          
          if [ -z "$VM_IP" ]; then
            echo "‚ö†Ô∏è  Could not get VM IP address"
            echo "ssh_working=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "VM IP: $VM_IP"
          
          # Verify SSH key file exists
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ö†Ô∏è  SSH private key file not found"
            echo "ssh_working=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Test SSH connection with short timeout
          SSH_WORKING=false
          if ssh -i ~/.ssh/id_rsa \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            -o BatchMode=yes \
            ${{ env.VM_ADMIN_USERNAME }}@$VM_IP 'echo "SSH_TEST_SUCCESS"' 2>/dev/null | grep -q "SSH_TEST_SUCCESS"; then
            SSH_WORKING=true
            echo "‚úÖ SSH connectivity test PASSED - VM is accessible"
          else
            echo "‚ùå SSH connectivity test FAILED - VM is not accessible via SSH"
            echo "This indicates SSH service is not running or VM is in a bad state"
          fi
          
          if [ "$SSH_WORKING" = "true" ]; then
            echo "ssh_working=true" >> $GITHUB_OUTPUT
          else
            echo "ssh_working=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract SSH public key from secret
        id: sshkey
        run: |
          set -e
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_STAGING }}"
          
          if [ -z "$SSH_KEY" ]; then
            echo "‚ùå Error: VM_SSH_PRIVATE_KEY_STAGING secret is empty or not set"
            echo "Please set the VM_SSH_PRIVATE_KEY_STAGING secret in GitHub repository settings"
            exit 1
          fi
          
          echo "Processing SSH key..."
          
          # Write private key temporarily to extract public key
          # Handle multiple possible formats: PEM (plain text), base64-encoded PEM, base64-encoded OpenSSH, or double-encoded
          
          # First, check if it's already in PEM format (plain text)
          if echo "$SSH_KEY" | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
            echo "‚úÖ Detected PEM format (plain text)"
          else
            # Try base64 decode first
            echo "Attempting base64 decode..."
            DECODED_KEY=$(echo "$SSH_KEY" | base64 -d 2>/dev/null || echo "")
            
            if [ -n "$DECODED_KEY" ]; then
              # Check what we got after first decode
              FIRST_DECODE=$(echo "$DECODED_KEY" | head -c 100)
              
              # Check if decoded content is OpenSSH format
              if echo "$FIRST_DECODE" | grep -q "openssh-key-v1"; then
                echo "$DECODED_KEY" > ~/.ssh/temp_key
                echo "‚úÖ Decoded base64 OpenSSH format key"
              # Check if decoded content is PEM format
              elif echo "$FIRST_DECODE" | grep -q "BEGIN.*PRIVATE KEY"; then
                echo "$DECODED_KEY" > ~/.ssh/temp_key
                echo "‚úÖ Decoded base64 PEM format key"
              # Check if decoded content is still base64-encoded (double encoding)
              elif echo "$FIRST_DECODE" | base64 -d > /dev/null 2>&1 && [ ${#FIRST_DECODE} -gt 50 ]; then
                echo "‚ö†Ô∏è  Detected possible double base64 encoding, attempting second decode..."
                DOUBLE_DECODED=$(echo "$DECODED_KEY" | base64 -d 2>/dev/null || echo "")
                if [ -n "$DOUBLE_DECODED" ]; then
                  DOUBLE_FIRST=$(echo "$DOUBLE_DECODED" | head -c 100)
                  if echo "$DOUBLE_FIRST" | grep -q "BEGIN.*PRIVATE KEY\|openssh-key-v1"; then
                    echo "$DOUBLE_DECODED" > ~/.ssh/temp_key
                    echo "‚úÖ Decoded double base64-encoded key"
                  else
                    # Try the first decode result
                    echo "$DECODED_KEY" > ~/.ssh/temp_key
                    echo "‚ö†Ô∏è  Double decode didn't produce recognizable format, using first decode result"
                  fi
                else
                  # Fall back to first decode
                  echo "$DECODED_KEY" > ~/.ssh/temp_key
                  echo "‚ö†Ô∏è  Second decode failed, using first decode result"
                fi
              else
                # Decoded content doesn't match known formats, but might still be valid
                # Check if it looks like binary data (DER format) that might work
                # Try using the decoded content - ssh-keygen will validate
                echo "$DECODED_KEY" > ~/.ssh/temp_key
                echo "‚ö†Ô∏è  Base64 decode succeeded but format unclear"
                echo "   Decoded content doesn't have standard PEM/OpenSSH markers"
                echo "   Will attempt to use decoded content - ssh-keygen will validate"
              fi
            else
              # Base64 decode failed, try as plain text
              echo "Base64 decode failed, trying as plain text..."
              echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
            fi
          fi
          chmod 600 ~/.ssh/temp_key
          
          # Validate key file before proceeding
          echo "Validating key file..."
          if [ ! -f ~/.ssh/temp_key ]; then
            echo "‚ùå Error: Key file was not created"
            exit 1
          fi
          
          KEY_SIZE=$(wc -c < ~/.ssh/temp_key 2>/dev/null || echo "0")
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå Error: Key file is too small ($KEY_SIZE bytes) - likely corrupted"
            exit 1
          fi
          
          KEY_TYPE=$(file ~/.ssh/temp_key 2>/dev/null || echo "unknown")
          echo "Key file type: $KEY_TYPE"
          echo "Key file size: $KEY_SIZE bytes"
          echo "Key file permissions: $(stat -c '%a' ~/.ssh/temp_key 2>/dev/null || stat -f '%A' ~/.ssh/temp_key 2>/dev/null || echo 'unknown')"
          
          # Check key format and convert if needed
          FIRST_BYTES=$(head -c 20 ~/.ssh/temp_key 2>/dev/null || echo "")
          echo "Key file first 20 bytes: $(echo "$FIRST_BYTES" | xxd -p | head -c 40)"
          
          # Validate key - try multiple validation methods
          echo "Validating key with ssh-keygen..."
          SSH_KEYGEN_OUTPUT=$(ssh-keygen -y -f ~/.ssh/temp_key 2>&1 || echo "SSH_KEYGEN_FAILED")
          
          if echo "$SSH_KEYGEN_OUTPUT" | grep -q "SSH_KEYGEN_FAILED"; then
            # ssh-keygen failed, get the actual error
            SSH_KEYGEN_ERROR=$(ssh-keygen -y -f ~/.ssh/temp_key 2>&1 || true)
            echo "Key validation failed, checking error details..."
            echo "ssh-keygen error: $SSH_KEYGEN_ERROR"
            
            # Check if it's an encrypted key
            if echo "$SSH_KEYGEN_ERROR" | grep -qi "encrypted\|passphrase"; then
              echo "‚ùå Error: Key appears to be encrypted with a passphrase"
              echo "Please provide an unencrypted private key (no passphrase)"
              exit 1
            fi
            
            # Check if it's a format issue
            if echo "$SSH_KEYGEN_ERROR" | grep -qi "invalid\|corrupt\|error in libcrypto"; then
              echo "‚ùå Error: SSH key format is invalid or corrupted"
              echo ""
              echo "Key file diagnostics:"
              echo "  - File type: $(file ~/.ssh/temp_key 2>/dev/null || echo 'unknown')"
              echo "  - File size: $(wc -c < ~/.ssh/temp_key) bytes"
              echo "  - First 50 chars (hex): $(head -c 50 ~/.ssh/temp_key | xxd -p | tr -d '\n' | head -c 100)"
              echo "  - Contains 'BEGIN': $(grep -q 'BEGIN' ~/.ssh/temp_key && echo 'Yes' || echo 'No')"
              echo "  - Contains 'PRIVATE': $(grep -q 'PRIVATE' ~/.ssh/temp_key && echo 'Yes' || echo 'No')"
              echo "  - Contains 'openssh-key-v1': $(head -c 50 ~/.ssh/temp_key | grep -q 'openssh-key-v1' && echo 'Yes' || echo 'No')"
              echo ""
              echo "The key in VM_SSH_PRIVATE_KEY_STAGING secret may be:"
              echo "  1. Corrupted during copy/paste"
              echo "  2. In an unsupported format"
              echo "  3. Double-encoded or incorrectly encoded"
              echo "  4. Missing required headers/footers"
              echo ""
              echo "Please verify the key content matches your local ~/.ssh/smartwatts_staging file exactly."
              exit 1
            fi
            
            # Unknown error - try to continue anyway (might work with SSH client)
            echo "‚ö†Ô∏è  Warning: Key validation failed with unknown error"
            echo "Attempting to continue - SSH client may still accept the key..."
          else
            echo "‚úÖ Key validation passed - can extract public key"
          fi
          
          # Try to extract public key (may fail for OpenSSH format, but that's OK)
          SSH_PUBLIC_KEY=$(ssh-keygen -y -f ~/.ssh/temp_key 2>/dev/null || echo "")
          
          if [ -n "$SSH_PUBLIC_KEY" ]; then
            echo "‚úÖ SSH public key extracted successfully"
            echo "public_key=$SSH_PUBLIC_KEY" >> $GITHUB_OUTPUT
            
            # Save public key to file
            echo "$SSH_PUBLIC_KEY" > ~/.ssh/id_rsa.pub
            chmod 644 ~/.ssh/id_rsa.pub
            echo "‚úÖ Public key saved for Bicep deployment"
          else
            echo "‚ö†Ô∏è  Warning: Could not extract SSH public key from private key"
            echo "This is OK - we'll use the key directly for SSH connections"
            echo "The VM will be created without SSH key in Bicep, but we'll add it via Azure CLI"
            echo "public_key=" >> $GITHUB_OUTPUT
          fi
          
          # Save private key for SSH connection (OpenSSH format is supported by modern SSH)
          echo "Copying key to id_rsa..."
          cp ~/.ssh/temp_key ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Verify id_rsa was created correctly
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: Failed to create ~/.ssh/id_rsa"
            exit 1
          fi
          
          ID_RSA_PERMS=$(stat -c '%a' ~/.ssh/id_rsa 2>/dev/null || stat -f '%A' ~/.ssh/id_rsa 2>/dev/null || echo "unknown")
          if [ "$ID_RSA_PERMS" != "600" ] && [ "$ID_RSA_PERMS" != "0600" ]; then
            echo "‚ö†Ô∏è  Warning: id_rsa permissions are $ID_RSA_PERMS, expected 600. Fixing..."
            chmod 600 ~/.ssh/id_rsa
            ID_RSA_PERMS=$(stat -c '%a' ~/.ssh/id_rsa 2>/dev/null || stat -f '%A' ~/.ssh/id_rsa 2>/dev/null || echo "unknown")
            echo "‚úÖ id_rsa permissions now: $ID_RSA_PERMS"
          else
            echo "‚úÖ id_rsa permissions correct: $ID_RSA_PERMS"
          fi
          
          # Verify key file is readable
          if [ ! -r ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: id_rsa is not readable"
            exit 1
          fi
          
          echo "‚úÖ SSH key setup complete"
          echo "Key file: ~/.ssh/id_rsa"
          echo "Key size: $(wc -c < ~/.ssh/id_rsa) bytes"
          echo "Key type: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          # Critical: Test if SSH can actually read the key
          echo ""
          echo "üîç Testing if SSH can read the key file..."
          SSH_TEST_OUTPUT=$(ssh-keygen -l -f ~/.ssh/id_rsa 2>&1 || echo "SSH_TEST_FAILED")
          
          if echo "$SSH_TEST_OUTPUT" | grep -qi "error\|libcrypto\|invalid\|corrupt"; then
            echo "‚ùå CRITICAL ERROR: SSH cannot read the key file"
            echo "SSH test output: $SSH_TEST_OUTPUT"
            echo ""
            echo "The key file appears to be corrupted, encrypted, or in an unsupported format."
            echo ""
            echo "Key file diagnostics:"
            echo "  - First 100 characters: $(head -c 100 ~/.ssh/id_rsa | tr -d '\n' | head -c 100)"
            echo "  - Last 100 characters: $(tail -c 100 ~/.ssh/id_rsa | tr -d '\n' | tail -c 100)"
            echo "  - Contains 'BEGIN': $(grep -q 'BEGIN' ~/.ssh/id_rsa && echo 'Yes' || echo 'No')"
            echo "  - Contains 'PRIVATE': $(grep -q 'PRIVATE' ~/.ssh/id_rsa && echo 'Yes' || echo 'No')"
            echo "  - Contains 'openssh-key-v1': $(head -c 50 ~/.ssh/id_rsa | grep -q 'openssh-key-v1' && echo 'Yes' || echo 'No')"
            echo ""
            echo "‚ùå ERROR: The SSH key in VM_SSH_PRIVATE_KEY_STAGING secret is invalid."
            echo "Please check:"
            echo "  1. The key is unencrypted (no passphrase)"
            echo "  2. The key is in PEM or OpenSSH format"
            echo "  3. The key was copied correctly (no extra spaces or line breaks)"
            echo "  4. The key is the complete private key (not just a portion)"
            exit 1
          else
            echo "‚úÖ SSH can read the key file"
            echo "Key fingerprint: $(echo "$SSH_TEST_OUTPUT" | grep -o '[a-f0-9:]*' | head -1 || echo 'N/A')"
          fi
          
          echo "‚úÖ SSH private key saved successfully"
          echo "Key file location: ~/.ssh/id_rsa"
          echo "Key file permissions: $(ls -l ~/.ssh/id_rsa | awk '{print $1}')"
          echo "Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
          echo "Key format: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          rm -f ~/.ssh/temp_key
          
      - name: Verify SSH key setup
        run: |
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: SSH private key file not found at ~/.ssh/id_rsa"
            echo "The SSH key extraction step must have failed"
            exit 1
          fi
          
          echo "‚úÖ SSH private key file found"
          echo "Private key: ~/.ssh/id_rsa ($(stat -c%s ~/.ssh/id_rsa 2>/dev/null || stat -f%z ~/.ssh/id_rsa 2>/dev/null) bytes)"
          echo "Key format: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          # Public key is optional (may not be extractable from OpenSSH format)
          if [ -f ~/.ssh/id_rsa.pub ]; then
            echo "‚úÖ SSH public key file found"
            echo "Public key: ~/.ssh/id_rsa.pub"
            echo "Public key fingerprint: $(ssh-keygen -lf ~/.ssh/id_rsa.pub 2>/dev/null | awk '{print $2}' || echo 'N/A')"
          else
            echo "‚ö†Ô∏è  SSH public key file not found (this is OK for OpenSSH format keys)"
            echo "The key will be used directly for SSH connections"
          fi
          
          echo "‚úÖ SSH key setup verified - ready for SSH connections"

      - name: Check if Key Vault exists
        id: kvcheck
        run: |
          # Key Vault names are globally unique, so check across all resource groups
          # First try to find it in any resource group
          KV_EXISTS=$(az keyvault list --query "[?name=='sw-staging-kv'] | length(@)" -o tsv 2>/dev/null || echo "0")
          
          # Also check for soft-deleted Key Vaults
          KV_DELETED=$(az keyvault list-deleted --query "[?name=='sw-staging-kv'] | length(@)" -o tsv 2>/dev/null || echo "0")
          
          if [ "$KV_EXISTS" != "0" ] || [ "$KV_DELETED" != "0" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            if [ "$KV_DELETED" != "0" ]; then
              echo "‚ö†Ô∏è  Key Vault exists in soft-deleted state - will not create"
            else
              echo "‚úÖ Key Vault already exists globally"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "üì¶ Key Vault does not exist - will be created"
          fi

      - name: Fix SSH on Existing VM (Non-Destructive)
        id: fixssh
        if: steps.vmcheck.outputs.exists == 'true' && steps.sshhealthcheck.outputs.ssh_working == 'false'
        timeout-minutes: 10
        run: |
          VM_NAME="${{ env.VM_NAME }}"
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "‚ö†Ô∏è  SSH connectivity test FAILED - attempting to fix SSH without deleting VM"
          echo "This preserves all data on the VM"
          echo ""
          
          # Step 1: Try VM redeploy (moves VM to new host, may fix agent issues)
          echo "Step 1: Attempting VM redeploy (moves VM to new host, preserves data)..."
          VM_STATE=$(az vm show \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --show-details \
            --query "powerState" \
            -o tsv 2>/dev/null || echo "Unknown")
          
          if [ "$VM_STATE" = "VM running" ]; then
            echo "VM is running. Redeploying VM (this may take 5-10 minutes)..."
            az vm redeploy \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --output none
            
            echo "Waiting for VM to be ready after redeploy..."
            sleep 60
            
            # Wait for VM to be running again
            MAX_WAIT=300
            ELAPSED=0
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CURRENT_STATE=$(az vm show \
                --resource-group $RESOURCE_GROUP \
                --name $VM_NAME \
                --show-details \
                --query "powerState" \
                -o tsv 2>/dev/null || echo "Unknown")
              
              if [ "$CURRENT_STATE" = "VM running" ]; then
                echo "‚úÖ VM is running after redeploy"
                break
              fi
              
              echo "VM state: $CURRENT_STATE (waiting... $ELAPSED/$MAX_WAIT seconds)"
              sleep 15
              ELAPSED=$((ELAPSED + 15))
            done
            
            echo "Waiting additional 60 seconds for VM agent and SSH service to be ready..."
            sleep 60
          else
            echo "VM is not running. Starting VM..."
            az vm start \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --output none
            
            echo "Waiting for VM to start..."
            sleep 60
          fi
          
          # Step 2: Deploy SSH extension to ensure SSH service is running
          echo ""
          echo "Step 2: Deploying SSH service extension..."
          
          # Remove existing extension if it exists (to ensure fresh deployment)
          EXTENSION_EXISTS=$(az vm extension list \
            --resource-group $RESOURCE_GROUP \
            --vm-name $VM_NAME \
            --query "[?name=='CustomScript' && publisher=='Microsoft.Azure.Extensions'].name" \
            -o tsv 2>/dev/null || echo "")
          
          if [ -n "$EXTENSION_EXISTS" ]; then
            echo "Removing existing CustomScript extension for fresh deployment..."
            az vm extension delete \
              --resource-group $RESOURCE_GROUP \
              --vm-name $VM_NAME \
              --name CustomScript \
              --output none 2>/dev/null || true
            sleep 10
          fi
          
          # Deploy SSH extension
          echo "Deploying SSH service extension..."
          az vm extension set \
            --resource-group $RESOURCE_GROUP \
            --vm-name $VM_NAME \
            --name CustomScript \
            --publisher Microsoft.Azure.Extensions \
            --version 2.1 \
            --settings '{"commandToExecute":"apt-get update -qq && apt-get install -y openssh-server && systemctl enable sshd && systemctl enable ssh && systemctl start sshd && systemctl start ssh && sleep 2 && systemctl status sshd || systemctl status ssh"}' \
            --output none
          
          echo "Waiting for extension to execute (up to 3 minutes)..."
          MAX_WAIT=180
          ELAPSED=0
          EXTENSION_STATE="Unknown"
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            EXTENSION_STATE=$(az vm extension show \
              --resource-group $RESOURCE_GROUP \
              --vm-name $VM_NAME \
              --name CustomScript \
              --query "provisioningState" -o tsv 2>/dev/null || echo "Unknown")
            
            if [ "$EXTENSION_STATE" = "Succeeded" ]; then
              echo "‚úÖ SSH extension executed successfully"
              break
            elif [ "$EXTENSION_STATE" = "Failed" ]; then
              echo "‚ö†Ô∏è  SSH extension execution failed"
              break
            fi
            
            echo "Extension state: $EXTENSION_STATE (waiting... $ELAPSED/$MAX_WAIT seconds)"
            sleep 15
            ELAPSED=$((ELAPSED + 15))
          done
          
          echo "Waiting additional 30 seconds for SSH service to fully start..."
          sleep 30
          
          echo ""
          echo "‚úÖ SSH fix attempt completed"
          echo "Note: If SSH still doesn't work, you may need to:"
          echo "  1. Use Azure Portal Serial Console to manually fix SSH"
          echo "  2. Or contact support for assistance"
          echo ""
          echo "Setting flag to indicate SSH fix was attempted..."
          echo "ssh_fix_attempted=true" >> $GITHUB_OUTPUT

      - name: Check and Handle Active Deployments
        id: check_deployments
        timeout-minutes: 10
        run: |
          set -e
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "Checking for active deployments in resource group: $RESOURCE_GROUP"
          
          # Check for active deployments
          ACTIVE_DEPLOYMENTS=$(az deployment group list \
            --resource-group $RESOURCE_GROUP \
            --query "[?properties.provisioningState=='Running' || properties.provisioningState=='InProgress'].name" \
            -o tsv 2>/dev/null || echo "")
          
          if [ -n "$ACTIVE_DEPLOYMENTS" ]; then
            echo "‚ö†Ô∏è  Found active deployment(s):"
            # Process each deployment name
            for DEPLOYMENT_NAME in $ACTIVE_DEPLOYMENTS; do
              if [ -n "$DEPLOYMENT_NAME" ]; then
                echo "  - $DEPLOYMENT_NAME"
                
                # Get deployment details
                DEPLOYMENT_STATE=$(az deployment group show \
                  --resource-group $RESOURCE_GROUP \
                  --name "$DEPLOYMENT_NAME" \
                  --query "properties.provisioningState" \
                  -o tsv 2>/dev/null || echo "Unknown")
                
                DEPLOYMENT_START=$(az deployment group show \
                  --resource-group $RESOURCE_GROUP \
                  --name "$DEPLOYMENT_NAME" \
                  --query "properties.timestamp" \
                  -o tsv 2>/dev/null || echo "Unknown")
                
                echo "    State: $DEPLOYMENT_STATE"
                echo "    Started: $DEPLOYMENT_START"
                
                # If deployment is active, poll for completion instead of using wait command
                if [ "$DEPLOYMENT_STATE" = "Running" ] || [ "$DEPLOYMENT_STATE" = "InProgress" ]; then
                  echo "    ‚è≥ Polling for deployment completion (max 10 minutes)..."
                  MAX_WAIT=600
                  ELAPSED=0
                  POLL_INTERVAL=15
                  
                  while [ $ELAPSED -lt $MAX_WAIT ]; do
                    CURRENT_STATE=$(az deployment group show \
                      --resource-group $RESOURCE_GROUP \
                      --name "$DEPLOYMENT_NAME" \
                      --query "properties.provisioningState" \
                      -o tsv 2>/dev/null || echo "Unknown")
                    
                    if [ "$CURRENT_STATE" = "Succeeded" ]; then
                      echo "    ‚úÖ Deployment '$DEPLOYMENT_NAME' completed successfully"
                      break
                    elif [ "$CURRENT_STATE" = "Failed" ] || [ "$CURRENT_STATE" = "Canceled" ]; then
                      echo "    ‚ö†Ô∏è  Deployment '$DEPLOYMENT_NAME' ended with state: $CURRENT_STATE"
                      # Show error details if available
                      ERROR_DETAILS=$(az deployment group show \
                        --resource-group $RESOURCE_GROUP \
                        --name "$DEPLOYMENT_NAME" \
                        --query "properties.error.message" \
                        -o tsv 2>/dev/null || echo "")
                      if [ -n "$ERROR_DETAILS" ]; then
                        echo "    Error: $ERROR_DETAILS"
                      fi
                      break
                    elif [ "$CURRENT_STATE" != "Running" ] && [ "$CURRENT_STATE" != "InProgress" ]; then
                      echo "    ‚ÑπÔ∏è  Deployment '$DEPLOYMENT_NAME' state: $CURRENT_STATE"
                      break
                    fi
                    
                    echo "    ‚è≥ Still running... (${ELAPSED}s elapsed, state: $CURRENT_STATE)"
                    sleep $POLL_INTERVAL
                    ELAPSED=$((ELAPSED + POLL_INTERVAL))
                  done
                  
                  # If still running after max wait, cancel it
                  FINAL_STATE=$(az deployment group show \
                    --resource-group $RESOURCE_GROUP \
                    --name "$DEPLOYMENT_NAME" \
                    --query "properties.provisioningState" \
                    -o tsv 2>/dev/null || echo "Unknown")
                  
                  if [ "$FINAL_STATE" = "Running" ] || [ "$FINAL_STATE" = "InProgress" ]; then
                    echo "    ‚ö†Ô∏è  Deployment '$DEPLOYMENT_NAME' is stuck, cancelling..."
                    az deployment group cancel \
                      --resource-group $RESOURCE_GROUP \
                      --name "$DEPLOYMENT_NAME" \
                      --output none 2>/dev/null || echo "    ‚ö†Ô∏è  Could not cancel (may have already completed/failed)"
                    sleep 5
                  fi
                fi
              fi
            done
            
            # Verify no active deployments remain
            sleep 5
            REMAINING_ACTIVE=$(az deployment group list \
              --resource-group $RESOURCE_GROUP \
              --query "[?properties.provisioningState=='Running' || properties.provisioningState=='InProgress'].name" \
              -o tsv 2>/dev/null || echo "")
            
            if [ -n "$REMAINING_ACTIVE" ]; then
              echo "‚ö†Ô∏è  Warning: Some deployments may still be active, but proceeding with new deployment"
            else
              echo "‚úÖ No active deployments remaining"
            fi
          else
            echo "‚úÖ No active deployments found"
          fi

      - name: Clean Up Orphaned OS Disk (if VM doesn't exist)
        id: cleanup_disk
        if: steps.vmcheck.outputs.exists == 'false'
        timeout-minutes: 5
        continue-on-error: true
        run: |
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          VM_NAME="${{ env.VM_NAME }}"
          OS_DISK_NAME="${VM_NAME}-osdisk"
          
          echo "Checking for orphaned OS disk (VM doesn't exist)..."
          
          # Check if OS disk exists
          DISK_EXISTS=$(az disk show \
            --resource-group $RESOURCE_GROUP \
            --name $OS_DISK_NAME \
            --query "name" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$DISK_EXISTS" ]; then
            echo "‚ö†Ô∏è  Found orphaned OS disk: $OS_DISK_NAME"
            echo "This disk is from a previous VM that was deleted"
            echo "Deleting orphaned disk to allow fresh VM creation..."
            
            # Check if disk is attached to anything
            DISK_STATE=$(az disk show \
              --resource-group $RESOURCE_GROUP \
              --name $OS_DISK_NAME \
              --query "diskState" -o tsv 2>/dev/null || echo "Unknown")
            
            echo "Disk state: $DISK_STATE"
            
            # Delete the orphaned disk
            az disk delete \
              --resource-group $RESOURCE_GROUP \
              --name $OS_DISK_NAME \
              --yes \
              --output none
            
            echo "‚úÖ Orphaned OS disk deleted successfully"
            echo "Fresh VM can now be created"
          else
            echo "‚úÖ No orphaned OS disk found"
          fi

      - name: Check if Infrastructure Deployment is Needed
        id: check_deployment
        run: |
          set -e
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          VM_NAME="${{ env.VM_NAME }}"
          
          echo "Checking if infrastructure deployment is needed..."
          
          # Check if VM exists with SSH keys
          VM_EXISTS=false
          VM_HAS_SSH_KEYS=false
          
          if [ "${{ steps.vmcheck.outputs.exists }}" = "true" ]; then
            VM_EXISTS=true
            if [ "${{ steps.vmsshcheck.outputs.has_ssh_keys }}" = "true" ]; then
              VM_HAS_SSH_KEYS=true
              echo "‚úÖ VM exists with SSH keys configured"
            else
              echo "‚ö†Ô∏è  VM exists but without SSH keys - deployment needed"
            fi
          else
            echo "üì¶ VM does not exist - deployment needed"
          fi
          
          # Check if Key Vault exists
          KEY_VAULT_EXISTS=false
          if [ "${{ steps.kvcheck.outputs.exists }}" = "true" ]; then
            KEY_VAULT_EXISTS=true
            echo "‚úÖ Key Vault exists"
          else
            echo "üì¶ Key Vault does not exist - deployment needed"
          fi
          
          # Determine if deployment is needed
          NEEDS_DEPLOYMENT=false
          
          # Deployment is needed if:
          # 1. VM doesn't exist
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ]; then
            NEEDS_DEPLOYMENT=true
            echo "Reason: VM does not exist"
          # 2. VM exists but has no SSH keys (needs to be created with SSH keys)
          elif [ "${{ steps.vmcheck.outputs.exists }}" = "true" ] && [ "${{ steps.vmsshcheck.outputs.has_ssh_keys }}" = "false" ]; then
            NEEDS_DEPLOYMENT=true
            echo "Reason: VM exists but has no SSH keys - VM needs SSH key configuration"
          # 3. VM exists with SSH keys but SSH connectivity test failed
          # We try to fix it non-destructively, but if that doesn't work, we still need deployment
          # to ensure the SSH extension runs
          elif [ "${{ steps.vmcheck.outputs.exists }}" = "true" ] && [ "${{ steps.sshhealthcheck.outputs.ssh_working }}" = "false" ]; then
            # We attempted to fix SSH, but deployment may still be needed to ensure extension runs
            # However, we don't want to recreate the VM, so we'll skip full deployment
            # and just ensure the extension is applied
            NEEDS_DEPLOYMENT=false
            echo "Reason: VM exists but SSH connectivity test failed"
            echo "Note: SSH fix was attempted non-destructively (VM redeploy + extension)"
            echo "      Full deployment skipped to preserve VM data"
          # 4. Key Vault doesn't exist and needs to be created
          elif [ "${{ steps.kvcheck.outputs.exists }}" = "false" ]; then
            NEEDS_DEPLOYMENT=true
            echo "Reason: Key Vault does not exist"
          else
            # All infrastructure exists and is properly configured
            NEEDS_DEPLOYMENT=false
            echo "‚úÖ All infrastructure already exists and is properly configured"
            echo "   - VM exists with SSH keys"
            echo "   - SSH connectivity test PASSED"
            echo "   - Key Vault exists"
            echo "   - No deployment needed"
          fi
          
          if [ "$NEEDS_DEPLOYMENT" = "true" ]; then
            echo "needs_deployment=true" >> $GITHUB_OUTPUT
            echo "üöÄ Infrastructure deployment is needed"
          else
            echo "needs_deployment=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  Skipping infrastructure deployment - all resources already exist"
          fi

      - name: Deploy Infrastructure via Bicep
        if: steps.check_deployment.outputs.needs_deployment == 'true'
        id: deploy
        timeout-minutes: 20
        run: |
          set -e
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          # Determine if we should deploy SSH extension
          # Always deploy for new VMs, but also deploy for existing VMs to ensure SSH service is running
          # The extension is idempotent and will just ensure SSH is enabled/started
          DEPLOY_SSH_EXTENSION=false
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ]; then
            DEPLOY_SSH_EXTENSION=true
            echo "VM doesn't exist - will deploy SSH extension"
          elif [ "${{ steps.vmcheck.outputs.exists }}" = "true" ] && [ "${{ steps.sshhealthcheck.outputs.ssh_working }}" = "false" ]; then
            DEPLOY_SSH_EXTENSION=true
            echo "VM exists but SSH failed - will deploy SSH extension to fix it"
          else
            # For existing VMs, also deploy extension to ensure SSH service is running
            # This is safe because the extension just ensures SSH is enabled/started
            DEPLOY_SSH_EXTENSION=true
            echo "VM already exists - will deploy SSH extension to ensure SSH service is running"
          fi
          
          # Use unique deployment name to avoid conflicts
          # Format: main-YYYYMMDD-HHMMSS-{short-commit-sha}
          DEPLOYMENT_NAME="main-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:7}"
          echo "Using deployment name: $DEPLOYMENT_NAME"
          
          DEPLOY_CMD="az deployment group create \
            --resource-group $RESOURCE_GROUP \
            --name $DEPLOYMENT_NAME \
            --template-file ${{ env.TEMPLATE_FILE }} \
            --parameters @${{ env.PARAM_FILE }} \
            --parameters vmAdminPassword=\"${{ secrets.VM_ADMIN_PASSWORD_STAGING }}\" \
            --parameters createKeyVault=$([ "${{ steps.kvcheck.outputs.exists }}" = "true" ] && echo "false" || echo "true") \
            --parameters deploySshExtension=$([ "$DEPLOY_SSH_EXTENSION" = "true" ] && echo "true" || echo "false") \
            --mode Incremental \
            --no-wait"

          # Pass SSH key if:
          # 1. VM doesn't exist, OR
          # 2. VM exists but has no SSH keys (needs SSH key configuration)
          NEEDS_SSH_KEY=false
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ]; then
            NEEDS_SSH_KEY=true
            echo "VM not found. Will create with SSH key."
          elif [ "${{ steps.vmsshcheck.outputs.has_ssh_keys }}" = "false" ]; then
            NEEDS_SSH_KEY=true
            echo "VM exists but has no SSH keys. Will configure with SSH key."
          fi
          
          if [ "$NEEDS_SSH_KEY" = "true" ]; then
            if [ -n "${{ steps.sshkey.outputs.public_key }}" ]; then
              echo "Injecting SSH key for VM creation."
              DEPLOY_CMD="$DEPLOY_CMD --parameters vmSshPublicKey=\"${{ steps.sshkey.outputs.public_key }}\""
              echo "‚úÖ Adding SSH public key to Bicep deployment"
              echo "Public key fingerprint: $(echo '${{ steps.sshkey.outputs.public_key }}' | ssh-keygen -lf - 2>/dev/null | awk '{print $2}' || echo 'N/A')"
            else
              echo "‚ùå Error: SSH public key is required for VM creation but is not available"
              echo "The SSH key extraction step must have failed"
              echo "Please check the 'Extract SSH public key from secret' step for errors"
              exit 1
            fi
          else
            echo "VM already exists with SSH keys. Skipping vmSshPublicKey parameter (Azure doesn't allow updating SSH keys via Bicep)."
          fi

          echo "Starting deployment (async mode to prevent hanging)..."
          eval "$DEPLOY_CMD"
          
          echo "Deployment started, monitoring progress..."
          MAX_WAIT=840  # 14 minutes (leaving 1 minute buffer before timeout)
          ELAPSED=0
          POLL_INTERVAL=30
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            DEPLOYMENT_STATE=$(az deployment group show \
              --resource-group $RESOURCE_GROUP \
              --name $DEPLOYMENT_NAME \
              --query "properties.provisioningState" \
              -o tsv 2>/dev/null || echo "Unknown")
            
            if [ "$DEPLOYMENT_STATE" = "Succeeded" ]; then
              echo "‚úÖ Deployment completed successfully"
              break
            elif [ "$DEPLOYMENT_STATE" = "Failed" ]; then
              echo "‚ùå Deployment failed"
              # Get error details
              ERROR=$(az deployment group show \
                --resource-group $RESOURCE_GROUP \
                --name $DEPLOYMENT_NAME \
                --query "properties.error" \
                -o json 2>/dev/null || echo "{}")
              echo "Error details: $ERROR"
              exit 1
            elif [ "$DEPLOYMENT_STATE" = "Canceled" ]; then
              echo "‚ö†Ô∏è  Deployment was canceled"
              exit 1
            elif [ "$DEPLOYMENT_STATE" = "Unknown" ]; then
              echo "‚ö†Ô∏è  Could not get deployment state, waiting..."
            else
              echo "‚è≥ Deployment in progress... State: $DEPLOYMENT_STATE (${ELAPSED}s elapsed)"
            fi
            
            sleep $POLL_INTERVAL
            ELAPSED=$((ELAPSED + POLL_INTERVAL))
          done
          
          # Final check
          FINAL_STATE=$(az deployment group show \
            --resource-group $RESOURCE_GROUP \
            --name $DEPLOYMENT_NAME \
            --query "properties.provisioningState" \
            -o tsv 2>/dev/null || echo "Unknown")
          
          if [ "$FINAL_STATE" != "Succeeded" ]; then
            echo "‚ùå Deployment did not complete successfully. Final state: $FINAL_STATE"
            if [ "$FINAL_STATE" = "Running" ] || [ "$FINAL_STATE" = "InProgress" ]; then
              echo "‚ö†Ô∏è  Deployment is still running but timed out. It will continue in the background."
              echo "You can check status with: az deployment group show --resource-group $RESOURCE_GROUP --name $DEPLOYMENT_NAME"
            fi
            exit 1
          fi

      - name: Skip Infrastructure Deployment
        if: steps.check_deployment.outputs.needs_deployment == 'false'
        run: |
          echo "‚è≠Ô∏è  Infrastructure deployment skipped"
          echo ""
          echo "All required infrastructure already exists:"
          echo "  ‚úÖ VM: ${{ env.VM_NAME }} exists with SSH keys"
          if [ "${{ steps.kvcheck.outputs.exists }}" = "true" ]; then
            echo "  ‚úÖ Key Vault: sw-staging-kv exists"
          fi
          echo ""
          echo "No changes needed. Proceeding to application deployment..."

      - name: Wait for VM Agent and Verify SSH Service
        timeout-minutes: 5
        if: steps.vmcheck.outputs.exists == 'false' || (steps.vmcheck.outputs.exists == 'true' && steps.vmsshcheck.outputs.has_ssh_keys == 'false')
        run: |
          VM_NAME="${{ env.VM_NAME }}"
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "Waiting for VM agent to be ready after creation..."
          echo "Note: VM agent may take several minutes to initialize on new VMs"
          MAX_WAIT=300
          ELAPSED=0
          VM_AGENT_READY=false
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Check VM agent status
            AGENT_STATUS=$(az vm show \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --instance-view \
              --query "instanceView.vmAgent.statuses[?code=='ProvisioningState/succeeded']" \
              -o json 2>/dev/null || echo "[]")
            
            if echo "$AGENT_STATUS" | grep -q "succeeded"; then
              echo "‚úÖ VM agent is ready"
              VM_AGENT_READY=true
              break
            fi
            
            # Also check if VM is at least running
            VM_STATE=$(az vm show \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --show-details \
              --query "powerState" \
              -o tsv 2>/dev/null || echo "Unknown")
            
            echo "Waiting for VM agent... ($ELAPSED/$MAX_WAIT seconds) - VM state: $VM_STATE"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ "$VM_AGENT_READY" = "false" ]; then
            echo "‚ùå Error: VM agent is not ready after $MAX_WAIT seconds"
            echo "VM agent must be ready for SSH extension to execute"
            echo "This may indicate a problem with the VM or VM agent installation"
            exit 1
          fi
          
          # Wait for custom script extension to complete
          echo "Waiting for SSH service configuration extension to complete..."
          sleep 30
          
          # Verify SSH service is running using VM run-command
          echo "Verifying SSH service is running..."
          SSH_CHECK=$(timeout 30 az vm run-command invoke \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --command-id RunShellScript \
            --scripts "systemctl is-active sshd || systemctl is-active ssh || echo 'inactive'" \
            --query "value[0].message" -o tsv 2>/dev/null | grep -v "Enable" || echo "unknown")
          
          if echo "$SSH_CHECK" | grep -qi "active\|running"; then
            echo "‚úÖ SSH service is running"
          else
            echo "‚ùå Error: SSH service is not running after extension execution"
            echo "SSH service status: $SSH_CHECK"
            echo "This indicates the SSH extension may have failed"
            exit 1
          fi
          
          # Verify SSH keys are actually configured on the VM
          echo ""
          echo "Verifying SSH keys are configured on the VM..."
          VM_SSH_KEYS=$(az vm show \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --query "osProfile.linuxConfiguration.ssh.publicKeys" \
            -o json 2>/dev/null || echo "[]")
          
          if [ "$VM_SSH_KEYS" = "[]" ] || [ "$VM_SSH_KEYS" = "null" ] || [ -z "$VM_SSH_KEYS" ]; then
            echo "‚ùå Error: VM was created but SSH keys are not configured!"
            echo "This should not happen - the Bicep template should have configured SSH keys"
            echo "VM SSH keys status: $VM_SSH_KEYS"
            exit 1
          else
            echo "‚úÖ SSH keys are properly configured on the VM"
            KEY_COUNT=$(echo "$VM_SSH_KEYS" | jq 'length' 2>/dev/null || echo "1")
            echo "Number of SSH keys configured: $KEY_COUNT"
          fi
          
          echo ""
          echo "‚úÖ VM creation verification complete"
          echo "Note: If VM agent wasn't ready, SSH extension will run automatically when agent initializes"

      - name: Retrieve VM Public IP
        id: get_ip
        run: |
          VM_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.PUBLIC_IP_NAME }} \
            --query "ipAddress" -o tsv)
          echo "VM_IP=$VM_IP" >> $GITHUB_ENV
          echo "VM IP: $VM_IP"

      - name: Update VM SSH key (if VM already existed)
        if: steps.vmcheck.outputs.exists == 'true' && steps.sshkey.outputs.public_key != ''
        run: |
          echo "Updating VM authorized_keys using Azure CLI..."
          if az vm user update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --username ${{ env.VM_ADMIN_USERNAME }} \
            --ssh-key-value "${{ steps.sshkey.outputs.public_key }}" 2>&1; then
            echo "‚úÖ SSH key updated successfully"
            echo "Waiting 30 seconds for key to propagate..."
            sleep 30
          else
            echo "‚ö†Ô∏è Warning: Failed to update SSH key via Azure CLI"
            echo "You may need to manually add the SSH key or recreate the VM"
          fi

      - name: Check and Start VM
        timeout-minutes: 5
        run: |
          VM_NAME="${{ env.VM_NAME }}"
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "Checking VM state..."
          VM_STATE=$(az vm show \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --show-details \
            --query "powerState" \
            -o tsv 2>/dev/null || echo "Unknown")
          
          echo "VM State: $VM_STATE"
          
          if [ "$VM_STATE" = "VM deallocated" ] || [ "$VM_STATE" = "VM stopped" ]; then
            echo "‚ö†Ô∏è  VM is stopped. Starting VM..."
            az vm start \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --output none
            
            echo "Waiting for VM to be fully started..."
            MAX_WAIT=300
            ELAPSED=0
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CURRENT_STATE=$(az vm show \
                --resource-group $RESOURCE_GROUP \
                --name $VM_NAME \
                --show-details \
                --query "powerState" \
                -o tsv 2>/dev/null || echo "Unknown")
              
              if [ "$CURRENT_STATE" = "VM running" ]; then
                echo "‚úÖ VM is running"
                echo "Waiting additional 30 seconds for SSH service to be ready..."
                sleep 30
                break
              fi
              
              echo "VM state: $CURRENT_STATE (waiting...)"
              sleep 10
              ELAPSED=$((ELAPSED + 10))
            done
            
            if [ "$CURRENT_STATE" != "VM running" ]; then
              echo "‚ö†Ô∏è  Warning: VM may not be fully started, but continuing..."
            fi
          elif [ "$VM_STATE" = "VM running" ]; then
            echo "‚úÖ VM is already running"
          else
            echo "‚ö†Ô∏è  Warning: VM state is '$VM_STATE' (unexpected)"
          fi

      - name: Check and Fix SSH Service
        timeout-minutes: 2
        run: |
          VM_NAME="${{ env.VM_NAME }}"
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "Checking SSH service status on VM using Azure VM run-command..."
          echo "Note: This step will timeout if VM agent is not responding, but deployment will continue"
          
          # Try to check SSH service with a short timeout
          SSH_STATUS="unknown"
          set +e  # Don't fail on errors in this step
          
          # Use timeout to prevent hanging
          SSH_CHECK_OUTPUT=$(timeout 30 az vm run-command invoke \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --command-id RunShellScript \
            --scripts "systemctl is-active sshd 2>/dev/null || systemctl is-active ssh 2>/dev/null || echo 'inactive'" \
            --query "value[0].message" -o tsv 2>/dev/null | grep -v "Enable" | head -1 || echo "timeout")
          
          if [ "$SSH_CHECK_OUTPUT" != "timeout" ] && [ -n "$SSH_CHECK_OUTPUT" ]; then
            SSH_STATUS="$SSH_CHECK_OUTPUT"
            echo "SSH service status: $SSH_STATUS"
          else
            echo "‚ö†Ô∏è  Could not check SSH service status (VM agent may not be responding)"
            echo "This is non-fatal - SSH may still be working"
            exit 0  # Exit successfully to continue deployment
          fi
          
          if echo "$SSH_STATUS" | grep -qi "inactive\|failed"; then
            echo "‚ö†Ô∏è  SSH service is not running. Attempting to start it..."
            
            # Start SSH service with timeout
            timeout 30 az vm run-command invoke \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --command-id RunShellScript \
              --scripts "sudo systemctl start sshd 2>/dev/null || sudo systemctl start ssh 2>/dev/null || sudo service ssh start 2>/dev/null || sudo service sshd start 2>/dev/null || true" \
              --output none 2>/dev/null || echo "‚ö†Ô∏è  Could not start SSH service (may need manual intervention)"
            
            echo "Waiting 15 seconds for SSH service to start..."
            sleep 15
            
            # Enable SSH service to start on boot (non-blocking)
            timeout 20 az vm run-command invoke \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --command-id RunShellScript \
              --scripts "sudo systemctl enable sshd 2>/dev/null || sudo systemctl enable ssh 2>/dev/null || true" \
              --output none 2>/dev/null || true
            
            echo "‚úÖ SSH service start command issued (if VM agent is responding)"
          else
            echo "‚úÖ SSH service appears to be running"
          fi
          
          set -e  # Re-enable error checking
          
          # Verify SSH is listening on port 22 (with timeout to prevent hanging)
          echo "Verifying SSH is listening on port 22..."
          PORT_CHECK=$(timeout 20 az vm run-command invoke \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --command-id RunShellScript \
            --scripts "sudo netstat -tlnp 2>/dev/null | grep ':22 ' || sudo ss -tlnp 2>/dev/null | grep ':22 ' || echo 'SSH not listening'" \
            --query "value[0].message" -o tsv 2>/dev/null | grep -v "Enable" | head -1 || echo "timeout")
          
          if echo "$PORT_CHECK" | grep -q "22"; then
            echo "‚úÖ SSH is listening on port 22"
          elif [ "$PORT_CHECK" = "timeout" ]; then
            echo "‚ö†Ô∏è  Could not verify SSH port (VM agent may not be responding)"
            echo "SSH service may still be running - will attempt connection anyway"
          else
            echo "‚ö†Ô∏è  Warning: SSH may not be listening on port 22"
            echo "Port check output: $PORT_CHECK"
          fi

      - name: Verify SSH Connection
        timeout-minutes: 3
        run: |
          MAX_RETRIES=5
          RETRY_DELAY=15
          COUNT=0

          echo "Verifying SSH connection to ${{ env.VM_IP }}..."
          
          # Check NSG rules
          echo "Checking NSG rules for SSH access..."
          NSG_NAME=$(az network nsg list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[?contains(name, 'nsg')].name" -o tsv | head -1)
          if [ -n "$NSG_NAME" ]; then
            echo "NSG: $NSG_NAME"
            az network nsg rule list --nsg-name "$NSG_NAME" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[?destinationPortRange=='22']" -o table || echo "Could not list NSG rules"
          fi
          
          # Check if SSH service is accessible
          echo "Testing SSH port connectivity..."
          timeout 5 bash -c "echo > /dev/tcp/${{ env.VM_IP }}/22" 2>/dev/null && echo "‚úÖ Port 22 is open" || echo "‚ö†Ô∏è  Port 22 may be blocked or SSH service not running"
          
          # Add VM to known_hosts (non-blocking)
          ssh-keyscan -H ${{ env.VM_IP }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add VM to known_hosts (will continue)"

          # Verify SSH key file exists
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ö†Ô∏è  Warning: SSH private key file not found at ~/.ssh/id_rsa"
            echo "SSH connection will likely fail. Continuing anyway..."
          else
            echo "‚úÖ SSH private key file found"
            # Test SSH connection with longer timeout and retry logic
            SSH_SUCCESS=false
            while [ $COUNT -lt $MAX_RETRIES ]; do
              echo "SSH connection attempt $((COUNT + 1)) of $MAX_RETRIES..."
              if ssh -i ~/.ssh/id_rsa \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null \
                -o ConnectTimeout=30 \
                -o ServerAliveInterval=10 \
                -o ServerAliveCountMax=3 \
                -o BatchMode=yes \
                ${{ env.VM_ADMIN_USERNAME }}@${{ env.VM_IP }} 'echo "SSH connection successful"' 2>&1; then
                SSH_SUCCESS=true
                break
              else
                echo "SSH attempt $((COUNT + 1)) failed"
                COUNT=$((COUNT + 1))
                if [ $COUNT -lt $MAX_RETRIES ]; then
                  echo "Waiting $RETRY_DELAY seconds before retry..."
                  sleep $RETRY_DELAY
                fi
              fi
            done
          fi

          if [ "$SSH_SUCCESS" != "true" ]; then
            echo "‚ùå Error: SSH connection verification failed after $MAX_RETRIES attempts."
            echo "VM IP: ${{ env.VM_IP }}"
            echo "VM State: $(az vm show -d --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query powerState -o tsv 2>/dev/null || echo 'unknown')"
            echo ""
            echo "SSH connection is required for deployment. Deployment cannot continue."
            echo ""
            echo "To troubleshoot:"
            echo "1. Check if SSH key was added: az vm show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query 'osProfile.linuxConfiguration.ssh.publicKeys'"
            echo "2. Check NSG rules allow SSH: az network nsg rule list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --nsg-name <nsg-name>"
            echo "3. Check VM boot diagnostics for errors"
            exit 1
          else
            echo "‚úÖ SSH connection verified successfully!"
          fi

      - name: Check if Repository Exists on VM
        timeout-minutes: 2
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          CHECK_SCRIPT='REPO_DIR=""; if [ -d "/home/azureuser/SmartWatts" ]; then REPO_DIR="/home/azureuser/SmartWatts"; elif [ -d "/home/azureuser/smartwatts" ]; then REPO_DIR="/home/azureuser/smartwatts"; fi; if [ -n "$REPO_DIR" ]; then FILE_COUNT=$(find "$REPO_DIR" -mindepth 1 -maxdepth 1 2>/dev/null | wc -l); if [ "$FILE_COUNT" -gt 0 ] && [ -d "$REPO_DIR/azure-deployment" ]; then echo "EXISTS"; else echo "EMPTY_OR_INCOMPLETE"; fi; else echo "NOT_FOUND"; fi'
          REPO_STATUS=$(ssh -o StrictHostKeyChecking=no \
                         -o UserKnownHostsFile=/dev/null \
                         -o ConnectTimeout=30 \
                         -o ServerAliveInterval=10 \
                         -o ServerAliveCountMax=3 \
                         -i ~/.ssh/id_rsa \
                         azureuser@$VM_IP "$CHECK_SCRIPT" 2>/dev/null || echo "NOT_FOUND")
          echo "REPO_STATUS=$REPO_STATUS" >> $GITHUB_ENV
          if [ "$REPO_STATUS" = "EXISTS" ]; then
            echo "‚úÖ Repository already exists on VM with azure-deployment directory, skipping copy/extract steps"
          elif [ "$REPO_STATUS" = "EMPTY_OR_INCOMPLETE" ]; then
            echo "‚ö†Ô∏è  Repository directory exists but is empty or missing azure-deployment directory"
            echo "Will re-extract repository to ensure it's complete"
            echo "REPO_STATUS=NOT_FOUND" >> $GITHUB_ENV
          else
            if [ "$REPO_STATUS" = "NOT_FOUND" ]; then
              echo "‚ö†Ô∏è  Could not verify repository status (SSH may have failed). Assuming repository needs to be copied."
              echo "REPO_STATUS=NOT_FOUND" >> $GITHUB_ENV
            else
              echo "üì¶ Repository not found, will copy and extract"
            fi
          fi

      - name: Copy Repository to VM
        timeout-minutes: 10
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          echo "Creating repository archive..."
          # Create tar.gz archive excluding unnecessary files
          tar czf /tmp/smartwatts.tar.gz \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.next' \
            --exclude='__tests__' \
            --exclude='e2e' \
            --exclude='*.log' \
            --exclude='.env*' \
            --exclude='dist' \
            --exclude='build' \
            --exclude='bin' \
            . 2>/dev/null || {
            echo "‚ùå Error: Failed to create repository archive"
            exit 1
          }
          
          echo "Repository archive created: $(du -h /tmp/smartwatts.tar.gz | cut -f1)"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Copying repository to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            if scp -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null \
                   -o ConnectTimeout=30 \
                   -o ServerAliveInterval=10 \
                   -o ServerAliveCountMax=3 \
                   -i ~/.ssh/id_rsa \
                   /tmp/smartwatts.tar.gz azureuser@$VM_IP:/tmp/smartwatts.tar.gz; then
              echo "‚úÖ Repository copied successfully"
              rm -f /tmp/smartwatts.tar.gz
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Copy failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "‚ùå Error: Failed to copy repository after $MAX_RETRIES attempts"
                rm -f /tmp/smartwatts.tar.gz
                exit 1
              fi
            fi
          done

      - name: Extract repository on VM
        timeout-minutes: 5
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Extracting repository on VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            
            EXTRACT_CMD="set -e && \
              cd /home/azureuser && \
              if [ -d \"smartwatts\" ]; then \
                echo \"Removing existing smartwatts directory...\" && \
                rm -rf smartwatts; \
              fi && \
              echo \"Verifying archive exists and has content...\" && \
              if [ ! -f \"/tmp/smartwatts.tar.gz\" ]; then \
                echo \"‚ùå Error: Archive file /tmp/smartwatts.tar.gz not found\" && \
                exit 1; \
              fi && \
              ARCHIVE_SIZE=\$(stat -c%s /tmp/smartwatts.tar.gz 2>/dev/null || stat -f%z /tmp/smartwatts.tar.gz 2>/dev/null || echo 0) && \
              if [ \"\$ARCHIVE_SIZE\" -eq 0 ]; then \
                echo \"‚ùå Error: Archive file is empty\" && \
                exit 1; \
              fi && \
              echo \"Archive size: \$ARCHIVE_SIZE bytes\" && \
              echo \"Listing archive contents (first 30 entries)...\" && \
              tar tzf /tmp/smartwatts.tar.gz | head -30 && \
              echo \"\" && \
              echo \"Checking archive structure...\" && \
              ROOT_DIRS=\$(tar tzf /tmp/smartwatts.tar.gz | head -1 | cut -d'/' -f1 | sort -u) && \
              echo \"Root directories in archive: \$ROOT_DIRS\" && \
              echo \"\" && \
              echo \"Creating target directory...\" && \
              mkdir -p /home/azureuser/smartwatts && \
              cd /home/azureuser/smartwatts && \
              echo \"Extracting archive directly to /home/azureuser/smartwatts...\" && \
              tar xzf /tmp/smartwatts.tar.gz && \
              echo \"\" && \
              echo \"Checking if archive had root directory...\" && \
              if [ -d \"SmartWatts\" ] && [ ! -d \"azure-deployment\" ]; then \
                echo \"Archive has SmartWatts root directory, moving contents up...\" && \
                mv SmartWatts/* . 2>/dev/null || cp -r SmartWatts/* . && \
                mv SmartWatts/.* . 2>/dev/null || true && \
                rmdir SmartWatts 2>/dev/null || true; \
              elif [ -d \"smartwatts\" ] && [ ! -d \"azure-deployment\" ]; then \
                echo \"Archive has smartwatts root directory, moving contents up...\" && \
                mv smartwatts/* . 2>/dev/null || cp -r smartwatts/* . && \
                mv smartwatts/.* . 2>/dev/null || true && \
                rmdir smartwatts 2>/dev/null || true; \
              fi && \
              echo \"\" && \
              echo \"Verifying extraction...\" && \
              echo \"Repository contents:\" && \
              ls -la /home/azureuser/smartwatts | head -30 && \
              echo \"\" && \
              echo \"Checking for azure-deployment directory...\" && \
              if [ -d \"/home/azureuser/smartwatts/azure-deployment\" ]; then \
                echo \"‚úÖ Found azure-deployment directory\" && \
                echo \"azure-deployment contents:\" && \
                ls -la /home/azureuser/smartwatts/azure-deployment | head -20; \
              else \
                echo \"‚ùå Error: azure-deployment directory not found after extraction\" && \
                echo \"Listing all top-level directories:\" && \
                find /home/azureuser/smartwatts -maxdepth 1 -type d | head -20 && \
                echo \"Listing all directories (maxdepth 2):\" && \
                find /home/azureuser/smartwatts -maxdepth 2 -type d | head -30 && \
                exit 1; \
              fi && \
              echo \"\" && \
              echo \"Cleaning up archive file...\" && \
              rm -f /tmp/smartwatts.tar.gz && \
              echo \"‚úÖ Repository extracted successfully with all directories preserved\""
            
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=30 \
                 -o ServerAliveInterval=10 \
                 -o ServerAliveCountMax=3 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$EXTRACT_CMD"; then
              echo "‚úÖ Repository extracted successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Extraction failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "‚ùå Error: Failed to extract repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Deploy Application to VM
        timeout-minutes: 60
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Deploying application to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            DEPLOY_SCRIPT=$(printf '%s\n' \
              'if ! command -v docker &> /dev/null; then' \
              '  echo "Installing Docker...";' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq ca-certificates curl gnupg lsb-release || true;' \
              '  sudo mkdir -p /etc/apt/keyrings;' \
              '  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg;' \
              '  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null;' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {' \
              '    echo "Docker CE installation failed, trying docker.io...";' \
              '    sudo apt-get install -y -qq docker.io docker-compose || { echo "Error: Docker installation failed"; exit 1; };' \
              '  };' \
              '  if ! command -v docker &> /dev/null; then' \
              '    echo "Error: Docker installation failed - docker command not found";' \
              '    exit 1;' \
              '  fi;' \
              '  if getent group docker > /dev/null 2>&1; then sudo usermod -aG docker $USER; fi;' \
              '  echo "Docker installed successfully";' \
              'fi;' \
              'if systemctl list-unit-files | grep -q docker.service; then' \
              '  sudo systemctl start docker || true;' \
              '  sudo systemctl enable docker || true;' \
              'else' \
              '  if ! sudo docker info > /dev/null 2>&1; then' \
              '    echo "Warning: Docker service not found, but Docker may still work";' \
              '    sudo dockerd > /dev/null 2>&1 &' \
              '    sleep 5;' \
              '  fi;' \
              'fi;' \
              'if ! sudo docker info > /dev/null 2>&1; then' \
              '  echo "Error: Docker daemon is not running";' \
              '  exit 1;' \
              'fi;' \
              'echo "Docker is installed and running";' \
              'DOCKER_COMPOSE_CMD="";' \
              'if command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1; then' \
              '  DOCKER_COMPOSE_CMD="docker compose";' \
              '  echo "Using Docker Compose plugin (docker compose)";' \
              'elif command -v docker-compose &> /dev/null; then' \
              '  DOCKER_COMPOSE_CMD="docker-compose";' \
              '  echo "Using docker-compose command";' \
              'elif [ -f /usr/local/bin/docker-compose ]; then' \
              '  DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose";' \
              '  echo "Using docker-compose from /usr/local/bin";' \
              'else' \
              '  echo "Installing docker-compose...";' \
              '  sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose;' \
              '  sudo chmod +x /usr/local/bin/docker-compose;' \
              '  DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose";' \
              '  echo "docker-compose installed to /usr/local/bin";' \
              'fi;' \
              'if [ -z "$DOCKER_COMPOSE_CMD" ]; then' \
              '  echo "ERROR: Could not find or install docker-compose";' \
              '  exit 1;' \
              'fi;' \
              'REPO_DIR="";' \
              'if [ -d "/home/azureuser/SmartWatts" ]; then' \
              '  REPO_DIR="/home/azureuser/SmartWatts";' \
              'elif [ -d "/home/azureuser/smartwatts" ]; then' \
              '  REPO_DIR="/home/azureuser/smartwatts";' \
              'else' \
              '  echo "Error: Repository not found. Expected /home/azureuser/SmartWatts or /home/azureuser/smartwatts";' \
              '  exit 1;' \
              'fi;' \
              'cd "$REPO_DIR";' \
              'echo "Using repository at: $REPO_DIR";' \
              'echo "Verifying Gradle wrapper files exist...";' \
              'MISSING_FILES=0;' \
              'for service_dir in backend/*-service backend/*-gateway backend/service-discovery; do' \
              '  if [ -d "$service_dir" ]; then' \
              '    if [ ! -f "$service_dir/gradle/wrapper/gradle-wrapper.jar" ]; then' \
              '      echo "ERROR: Missing gradle-wrapper.jar in $service_dir";' \
              '      MISSING_FILES=$((MISSING_FILES + 1));' \
              '    else' \
              '      echo "‚úì Found gradle-wrapper.jar in $service_dir";' \
              '    fi;' \
              '  fi;' \
              'done;' \
              'if [ $MISSING_FILES -gt 0 ]; then' \
              '  echo "ERROR: $MISSING_FILES service(s) missing gradle-wrapper.jar files";' \
              '  echo "Listing backend directory structure:";' \
              '  find backend -name "gradle-wrapper.jar" -type f || echo "No gradle-wrapper.jar files found";' \
              '  exit 1;' \
              'fi;' \
              'echo "All Gradle wrapper files verified successfully";' \
              'cd "$REPO_DIR/azure-deployment" || { echo "‚ùå Error: azure-deployment directory not found in $REPO_DIR"; echo "Repository contents:"; ls -la "$REPO_DIR" | head -30; exit 1; };' \
              'export POSTGRES_PASSWORD="${POSTGRES_PASSWORD:-SmartWatts2024!}";' \
              'echo "Starting Docker Compose services using: $DOCKER_COMPOSE_CMD";' \
              'if echo "$DOCKER_COMPOSE_CMD" | grep -q "docker compose"; then' \
              '  if ! sudo docker compose -f docker-compose.azure.yml up -d --build; then' \
              '    echo "ERROR: Docker Compose failed to start services";' \
              '    echo "Container logs:";' \
              '    sudo docker compose -f docker-compose.azure.yml logs --tail=50 || true;' \
              '    exit 1;' \
              '  fi;' \
              '  COMPOSE_CMD="docker compose";' \
              'else' \
              '  if ! sudo $DOCKER_COMPOSE_CMD -f docker-compose.azure.yml up -d --build; then' \
              '    echo "ERROR: Docker Compose failed to start services";' \
              '    echo "Container logs:";' \
              '    sudo $DOCKER_COMPOSE_CMD -f docker-compose.azure.yml logs --tail=50 || true;' \
              '    exit 1;' \
              '  fi;' \
              '  COMPOSE_CMD="$DOCKER_COMPOSE_CMD";' \
              'fi;' \
              'echo "Starting Docker Compose build (this may take 20-40 minutes for first build)...";' \
              'echo "Note: Gradle builds for all services can take significant time";' \
              'if echo "$COMPOSE_CMD" | grep -q "docker compose"; then' \
              '  if ! sudo docker compose -f docker-compose.azure.yml up -d --build; then' \
              '    echo "ERROR: Docker Compose build failed";' \
              '    echo "Container logs:";' \
              '    sudo docker compose -f docker-compose.azure.yml logs --tail=50 || true;' \
              '    exit 1;' \
              '  fi;' \
              'else' \
              '  if ! sudo $COMPOSE_CMD -f docker-compose.azure.yml up -d --build; then' \
              '    echo "ERROR: Docker Compose build failed";' \
              '    echo "Container logs:";' \
              '    sudo $COMPOSE_CMD -f docker-compose.azure.yml logs --tail=50 || true;' \
              '    exit 1;' \
              '  fi;' \
              'fi;' \
              'echo "Docker Compose build completed successfully";' \
              'echo "Waiting for containers to be ready...";' \
              'echo "Note: Spring Boot services may take 2-3 minutes to fully start";' \
              'MAX_WAIT=900;' \
              'ELAPSED=0;' \
              'ALL_READY=false;' \
              'while [ $ELAPSED -lt $MAX_WAIT ]; do' \
              '  if echo "$COMPOSE_CMD" | grep -q "docker compose"; then' \
              '    CONTAINER_STATUS=$(sudo docker compose -f docker-compose.azure.yml ps --format json 2>/dev/null || echo "[]");' \
              '  else' \
              '    CONTAINER_STATUS=$(sudo $COMPOSE_CMD -f docker-compose.azure.yml ps --format json 2>/dev/null || echo "[]");' \
              '  fi;' \
              '  TOTAL_CONTAINERS=$(echo "$CONTAINER_STATUS" | grep -c "Name" || echo "0");' \
              '  RUNNING_CONTAINERS=$(echo "$CONTAINER_STATUS" | grep -c '"'"'"State":"running"'"'"' || echo "0");' \
              '  if [ "$TOTAL_CONTAINERS" -gt 0 ] && [ "$RUNNING_CONTAINERS" -eq "$TOTAL_CONTAINERS" ]; then' \
              '    echo "All $RUNNING_CONTAINERS containers are running - checking service readiness...";' \
              '    sleep 5;' \
              '    BACKEND_READY=false;' \
              '    FRONTEND_READY=false;' \
              '    if command -v curl > /dev/null 2>&1; then' \
              '      if curl -f -s http://localhost:8080/actuator/health > /dev/null 2>&1; then' \
              '        BACKEND_READY=true;' \
              '        echo "‚úÖ Backend API Gateway is responding on port 8080";' \
              '      else' \
              '        echo "‚è≥ Backend API Gateway not yet ready (port 8080)";' \
              '      fi;' \
              '      if curl -f -s http://localhost:3000 > /dev/null 2>&1; then' \
              '        FRONTEND_READY=true;' \
              '        echo "‚úÖ Frontend is responding on port 3000";' \
              '      else' \
              '        echo "‚è≥ Frontend not yet ready (port 3000)";' \
              '      fi;' \
              '    elif command -v nc > /dev/null 2>&1 || command -v netcat > /dev/null 2>&1; then' \
              '      NC_CMD=$(command -v nc || command -v netcat);' \
              '      if timeout 2 $NC_CMD -z localhost 8080 2>/dev/null; then' \
              '        BACKEND_READY=true;' \
              '        echo "‚úÖ Backend port 8080 is listening";' \
              '      else' \
              '        echo "‚è≥ Backend port 8080 not yet ready";' \
              '      fi;' \
              '      if timeout 2 $NC_CMD -z localhost 3000 2>/dev/null; then' \
              '        FRONTEND_READY=true;' \
              '        echo "‚úÖ Frontend port 3000 is listening";' \
              '      else' \
              '        echo "‚è≥ Frontend port 3000 not yet ready";' \
              '      fi;' \
              '    fi;' \
              '    if [ "$BACKEND_READY" = "true" ] && [ "$FRONTEND_READY" = "true" ]; then' \
              '      echo "‚úÖ Both frontend and backend are ready!";' \
              '      ALL_READY=true;' \
              '      break;' \
              '    elif [ "$BACKEND_READY" = "false" ] && [ "$FRONTEND_READY" = "false" ]; then' \
              '      echo "‚è≥ Services still starting up...";' \
              '    fi;' \
              '  else' \
              '    echo "‚è≥ Containers still starting ($RUNNING_CONTAINERS/$TOTAL_CONTAINERS running)...";' \
              '  fi;' \
              '  echo "Waiting for services... ($ELAPSED/$MAX_WAIT seconds)";' \
              '  sleep 15;' \
              '  ELAPSED=$((ELAPSED + 15));' \
              'done;' \
              'if [ "$ALL_READY" = "true" ]; then' \
              '  echo "";' \
              '  echo "‚úÖ All services are ready";' \
              '  echo "";' \
              '  echo "Deployment completed successfully!";' \
              '  echo "Services status:";' \
              '  if echo "$COMPOSE_CMD" | grep -q "docker compose"; then' \
              '    sudo docker compose -f docker-compose.azure.yml ps;' \
              '  else' \
              '    sudo $COMPOSE_CMD -f docker-compose.azure.yml ps;' \
              '  fi;' \
              'else' \
              '  echo "";' \
              '  echo "‚ö†Ô∏è  Warning: Services may not be fully ready after $MAX_WAIT seconds";' \
              '  echo "Container status:";' \
              '  if echo "$COMPOSE_CMD" | grep -q "docker compose"; then' \
              '    sudo docker compose -f docker-compose.azure.yml ps;' \
              '    echo "";' \
              '    echo "Recent logs:";' \
              '    sudo docker compose -f docker-compose.azure.yml logs --tail=30;' \
              '  else' \
              '    sudo $COMPOSE_CMD -f docker-compose.azure.yml ps;' \
              '    echo "";' \
              '    echo "Recent logs:";' \
              '    sudo $COMPOSE_CMD -f docker-compose.azure.yml logs --tail=30;' \
              '  fi;' \
              '  echo "";' \
              '  echo "Deployment may need more time to complete. Services will continue starting.";' \
              'fi')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=30 \
                 -o ServerAliveInterval=10 \
                 -o ServerAliveCountMax=3 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$DEPLOY_SCRIPT"; then
              echo "Application deployed successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Deployment failed, retrying in $((RETRY_COUNT * 10)) seconds..."
                sleep $((RETRY_COUNT * 10))
              else
                echo "Error: Failed to deploy application after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Check if Static Web App exists
        id: swacheck
        continue-on-error: true
        run: |
          STATIC_APP_NAME="sw-staging-dashboard"
          if az staticwebapp show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name $STATIC_APP_NAME >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Static Web App found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Static Web App '$STATIC_APP_NAME' not found"
          fi
          
          if [ -z "${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}" ]; then
            echo "token_set=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Warning: AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING secret is not set"
          else
            echo "token_set=true" >> $GITHUB_OUTPUT
            echo "‚úÖ API token is set"
          fi

      - name: Static Web App prerequisites summary
        run: |
          if [ "${{ steps.swacheck.outputs.exists }}" != "true" ]; then
            echo "‚ö†Ô∏è  Azure Static Web App 'sw-staging-dashboard' was not found in resource group ${{ env.AZURE_RESOURCE_GROUP }}."
            echo "    The deployment step will be skipped until the app is created."
          elif [ "${{ steps.swacheck.outputs.token_set }}" != "true" ]; then
            echo "‚ö†Ô∏è  Secret AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING is missing."
            echo "    Add the deployment token from the Azure portal to proceed."
          else
            echo "‚úÖ Static Web App exists and API token is set. Deployment will proceed."
          fi

      - name: Deploy Frontend to Static Web Apps
        timeout-minutes: 10
        if: steps.swacheck.outputs.exists == 'true' && steps.swacheck.outputs.token_set == 'true'
        continue-on-error: true
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "frontend"
          output_location: ".next"
          skip_app_build: false
          skip_api_build: true

      - name: Get Deployment Outputs
        run: |
          echo "VM Public IP: ${{ env.VM_IP }}"
          echo "Static Web App URL: $(az staticwebapp show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-staging-dashboard \
            --query defaultHostname -o tsv 2>/dev/null || echo 'Not available')"

      - name: Health Check
        timeout-minutes: 10
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=20
          RETRY_COUNT=0
          WAIT_INTERVAL=15
          
          BACKEND_HEALTH_URL="http://$VM_IP:8080/api/v1/health"
          echo "Performing health checks..."
          echo "  - Backend API: $BACKEND_HEALTH_URL"
          echo "  - Frontend: http://$VM_IP:3000"
          echo "  - Frontend (via Nginx): http://$VM_IP"
          echo ""
          echo "Note: Services should already be ready (deployment step waits for readiness)"
          echo "Starting health checks immediately..."
          
          BACKEND_HEALTHY=false
          FRONTEND_HEALTHY=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo ""
            echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            
            # Check Backend API
            if [ "$BACKEND_HEALTHY" = "false" ]; then
              CURL_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" "$BACKEND_HEALTH_URL" 2>&1 || echo "CURL_ERROR")
              BACKEND_STATUS=$(echo "$CURL_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
              
              if [ "$BACKEND_STATUS" = "200" ]; then
                echo "‚úÖ Backend API is healthy (HTTP 200)"
                BACKEND_HEALTHY=true
              else
                echo "‚ö†Ô∏è  Backend API not responding (HTTP $BACKEND_STATUS)"
              fi
            fi
            
            # Check Frontend (port 3000)
            if [ "$FRONTEND_HEALTHY" = "false" ]; then
              FRONTEND_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" http://$VM_IP:3000 2>&1 || echo "CURL_ERROR")
              FRONTEND_STATUS=$(echo "$FRONTEND_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
              
              if [ "$FRONTEND_STATUS" = "200" ] || [ "$FRONTEND_STATUS" = "301" ] || [ "$FRONTEND_STATUS" = "302" ]; then
                echo "‚úÖ Frontend is accessible on port 3000 (HTTP $FRONTEND_STATUS)"
                FRONTEND_HEALTHY=true
              else
                echo "‚ö†Ô∏è  Frontend not responding on port 3000 (HTTP $FRONTEND_STATUS)"
              fi
            fi
            
            # Check Frontend via Nginx (port 80)
            NGINX_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" http://$VM_IP 2>&1 || echo "CURL_ERROR")
            NGINX_STATUS=$(echo "$NGINX_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
            if [ "$NGINX_STATUS" = "200" ] || [ "$NGINX_STATUS" = "301" ] || [ "$NGINX_STATUS" = "302" ]; then
              echo "‚úÖ Frontend accessible via Nginx on port 80 (HTTP $NGINX_STATUS)"
            else
              echo "‚ö†Ô∏è  Nginx not responding on port 80 (HTTP $NGINX_STATUS)"
            fi
            
            if [ "$BACKEND_HEALTHY" = "true" ] && [ "$FRONTEND_HEALTHY" = "true" ]; then
              echo ""
              echo "‚úÖ All health checks passed!"
              echo "   Frontend: http://$VM_IP:3000 or http://$VM_IP"
              echo "   Backend API: http://$VM_IP:8080"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              if [ "$BACKEND_STATUS" = "000" ]; then
                echo "‚ö†Ô∏è  Health check failed (HTTP $BACKEND_STATUS) - Connection refused or service not running"
                if [ $RETRY_COUNT -eq 1 ]; then
                  echo "Diagnostics:"
                  echo "  - Checking if port 8080 is accessible..."
                  timeout 3 bash -c "echo > /dev/tcp/$VM_IP/8080" 2>/dev/null && echo "    ‚úÖ Port 8080 is open" || echo "    ‚ùå Port 8080 is not accessible"
                  echo "  - This may be normal if the application hasn't been deployed yet (SSH may have failed)"
                fi
              else
                echo "Health check failed, retrying in $WAIT_INTERVAL seconds..."
              fi
              
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $WAIT_INTERVAL
              else
                echo "‚ùå Error: Health checks failed after $MAX_RETRIES attempts"
                echo "   Backend API: HTTP $BACKEND_STATUS"
                echo "   Frontend: HTTP $FRONTEND_STATUS"
                echo ""
                echo "Possible reasons:"
                echo "  1. Application deployment failed (check SSH connection and deployment logs above)"
                echo "  2. Application is still starting up (may need more time)"
                echo "  3. Port 8080 is not accessible (check NSG rules and firewall)"
                echo "  4. Application crashed or failed to start"
                echo ""
                echo "‚ùå Health check failed - workflow will fail"
                echo "Please check the VM and application deployment status."
                exit 1
              fi
            fi
          done
          
          # If we reach here, health checks failed
          echo ""
          echo "‚ùå Error: Health checks failed - maximum retries reached"
          echo "   Backend API: $([ "$BACKEND_HEALTHY" = "true" ] && echo "‚úÖ Healthy" || echo "‚ùå Not responding")"
          echo "   Frontend: $([ "$FRONTEND_HEALTHY" = "true" ] && echo "‚úÖ Healthy" || echo "‚ùå Not responding")"
          echo ""
          echo "Please check the VM and application deployment status."
          exit 1

      - name: Post-Deployment Summary
        run: |
          echo "‚úÖ Deployment completed."
          echo "VM IP: ${{ env.VM_IP }}"
          echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "Deployment Name: main"
