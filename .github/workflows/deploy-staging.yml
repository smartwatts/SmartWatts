name: Deploy Staging (main branch)

on:
  push:
    branches: [ "main" ]
    paths:
      - 'frontend/**'
      - 'backend/**'
      - 'infrastructure/**'
      - 'azure-deployment/**'
      - '.github/workflows/deploy-staging.yml'
      - '!docs/**'
      - '!*.md'
      - '!.github/workflows/*.md'
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-staging-rg
  ENVIRONMENT: staging
  LOCATION: centralus
  VM_NAME: sw-staging-vm
  VM_ADMIN_USERNAME: azureuser
  TEMPLATE_FILE: infrastructure/bicep/main.bicep
  PARAM_FILE: infrastructure/bicep/params.staging.json
  PUBLIC_IP_NAME: sw-staging-vm-pip

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_STAGING }}

      - name: Check and Recreate Resource Group
        timeout-minutes: 5
        run: |
          # Check if resource group exists
          if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            CURRENT_LOCATION=$(az group show --name ${{ env.AZURE_RESOURCE_GROUP }} --query location -o tsv)
            echo "Resource group exists in location: $CURRENT_LOCATION"
            
            # If location doesn't match, delete and recreate
            if [ "$CURRENT_LOCATION" != "${{ env.LOCATION }}" ]; then
              echo "‚ö†Ô∏è  Resource group is in $CURRENT_LOCATION, but we need ${{ env.LOCATION }}"
              echo "üóëÔ∏è  Deleting existing resource group to recreate in ${{ env.LOCATION }}..."
              az group delete --name ${{ env.AZURE_RESOURCE_GROUP }} --yes --no-wait
              echo "‚è≥ Waiting for deletion to complete (this may take a few minutes)..."
              
              # Wait for deletion (max 10 minutes)
              MAX_WAIT=600
              ELAPSED=0
              while az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null && [ $ELAPSED -lt $MAX_WAIT ]; do
                echo -n "."
                sleep 10
                ELAPSED=$((ELAPSED + 10))
              done
              echo ""
              
              if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
                echo "‚ùå Error: Resource group deletion timed out"
                echo "Please delete it manually: az group delete --name ${{ env.AZURE_RESOURCE_GROUP }} --yes"
                exit 1
              else
                echo "‚úÖ Resource group deleted successfully"
              fi
            else
              echo "‚úÖ Resource group is already in the correct location"
            fi
          fi
          
          # Create resource group if it doesn't exist
          if ! az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
            echo "üì¶ Creating resource group in ${{ env.LOCATION }}..."
            az group create \
              --name ${{ env.AZURE_RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }} \
              --output none
            echo "‚úÖ Resource group created"
          fi

      - name: Check if VM exists
        id: vmcheck
        run: |
          echo "Checking if ${{ env.VM_NAME }} exists in resource group ${{ env.AZURE_RESOURCE_GROUP }}"
          if az vm show --name ${{ env.VM_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "VM already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "VM does not exist - will be created"
          fi

      - name: Check if VM has SSH keys configured
        id: vmsshcheck
        if: steps.vmcheck.outputs.exists == 'true'
        run: |
          echo "Checking if existing VM has SSH keys configured..."
          SSH_KEYS=$(az vm show \
            --name ${{ env.VM_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --query "osProfile.linuxConfiguration.ssh.publicKeys" \
            -o json 2>/dev/null || echo "[]")
          
          # Check if SSH keys array is empty or null
          if [ "$SSH_KEYS" = "[]" ] || [ "$SSH_KEYS" = "null" ] || [ -z "$SSH_KEYS" ]; then
            echo "has_ssh_keys=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  VM exists but has no SSH keys configured"
            echo "This VM was likely created incorrectly and needs to be recreated"
          else
            echo "has_ssh_keys=true" >> $GITHUB_OUTPUT
            echo "‚úÖ VM has SSH keys configured"
            echo "SSH keys: $SSH_KEYS"
          fi

      - name: Extract SSH public key from secret
        id: sshkey
        run: |
          set -e
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_STAGING }}"
          
          if [ -z "$SSH_KEY" ]; then
            echo "‚ùå Error: VM_SSH_PRIVATE_KEY_STAGING secret is empty or not set"
            echo "Please set the VM_SSH_PRIVATE_KEY_STAGING secret in GitHub repository settings"
            exit 1
          fi
          
          echo "Processing SSH key..."
          
          # Write private key temporarily to extract public key
          # Handle multiple possible formats: PEM (plain text), base64-encoded PEM, base64-encoded OpenSSH, or double-encoded
          
          # First, check if it's already in PEM format (plain text)
          if echo "$SSH_KEY" | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
            echo "‚úÖ Detected PEM format (plain text)"
          else
            # Try base64 decode first
            echo "Attempting base64 decode..."
            DECODED_KEY=$(echo "$SSH_KEY" | base64 -d 2>/dev/null || echo "")
            
            if [ -n "$DECODED_KEY" ]; then
              # Check what we got after first decode
              FIRST_DECODE=$(echo "$DECODED_KEY" | head -c 100)
              
              # Check if decoded content is OpenSSH format
              if echo "$FIRST_DECODE" | grep -q "openssh-key-v1"; then
                echo "$DECODED_KEY" > ~/.ssh/temp_key
                echo "‚úÖ Decoded base64 OpenSSH format key"
              # Check if decoded content is PEM format
              elif echo "$FIRST_DECODE" | grep -q "BEGIN.*PRIVATE KEY"; then
                echo "$DECODED_KEY" > ~/.ssh/temp_key
                echo "‚úÖ Decoded base64 PEM format key"
              # Check if decoded content is still base64-encoded (double encoding)
              elif echo "$FIRST_DECODE" | base64 -d > /dev/null 2>&1 && [ ${#FIRST_DECODE} -gt 50 ]; then
                echo "‚ö†Ô∏è  Detected possible double base64 encoding, attempting second decode..."
                DOUBLE_DECODED=$(echo "$DECODED_KEY" | base64 -d 2>/dev/null || echo "")
                if [ -n "$DOUBLE_DECODED" ]; then
                  DOUBLE_FIRST=$(echo "$DOUBLE_DECODED" | head -c 100)
                  if echo "$DOUBLE_FIRST" | grep -q "BEGIN.*PRIVATE KEY\|openssh-key-v1"; then
                    echo "$DOUBLE_DECODED" > ~/.ssh/temp_key
                    echo "‚úÖ Decoded double base64-encoded key"
                  else
                    # Try the first decode result
                    echo "$DECODED_KEY" > ~/.ssh/temp_key
                    echo "‚ö†Ô∏è  Double decode didn't produce recognizable format, using first decode result"
                  fi
                else
                  # Fall back to first decode
                  echo "$DECODED_KEY" > ~/.ssh/temp_key
                  echo "‚ö†Ô∏è  Second decode failed, using first decode result"
                fi
              else
                # Decoded content doesn't match known formats, but might still be valid
                # Check if it looks like binary data (DER format) that might work
                # Try using the decoded content - ssh-keygen will validate
                echo "$DECODED_KEY" > ~/.ssh/temp_key
                echo "‚ö†Ô∏è  Base64 decode succeeded but format unclear"
                echo "   Decoded content doesn't have standard PEM/OpenSSH markers"
                echo "   Will attempt to use decoded content - ssh-keygen will validate"
              fi
            else
              # Base64 decode failed, try as plain text
              echo "Base64 decode failed, trying as plain text..."
              echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/temp_key
            fi
          fi
          chmod 600 ~/.ssh/temp_key
          
          # Validate key file before proceeding
          echo "Validating key file..."
          if [ ! -f ~/.ssh/temp_key ]; then
            echo "‚ùå Error: Key file was not created"
            exit 1
          fi
          
          KEY_SIZE=$(wc -c < ~/.ssh/temp_key 2>/dev/null || echo "0")
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå Error: Key file is too small ($KEY_SIZE bytes) - likely corrupted"
            exit 1
          fi
          
          KEY_TYPE=$(file ~/.ssh/temp_key 2>/dev/null || echo "unknown")
          echo "Key file type: $KEY_TYPE"
          echo "Key file size: $KEY_SIZE bytes"
          echo "Key file permissions: $(stat -c '%a' ~/.ssh/temp_key 2>/dev/null || stat -f '%A' ~/.ssh/temp_key 2>/dev/null || echo 'unknown')"
          
          # Check key format and convert if needed
          FIRST_BYTES=$(head -c 20 ~/.ssh/temp_key 2>/dev/null || echo "")
          echo "Key file first 20 bytes: $(echo "$FIRST_BYTES" | xxd -p | head -c 40)"
          
          # Validate key - try multiple validation methods
          echo "Validating key with ssh-keygen..."
          SSH_KEYGEN_OUTPUT=$(ssh-keygen -y -f ~/.ssh/temp_key 2>&1 || echo "SSH_KEYGEN_FAILED")
          
          if echo "$SSH_KEYGEN_OUTPUT" | grep -q "SSH_KEYGEN_FAILED"; then
            # ssh-keygen failed, get the actual error
            SSH_KEYGEN_ERROR=$(ssh-keygen -y -f ~/.ssh/temp_key 2>&1 || true)
            echo "Key validation failed, checking error details..."
            echo "ssh-keygen error: $SSH_KEYGEN_ERROR"
            
            # Check if it's an encrypted key
            if echo "$SSH_KEYGEN_ERROR" | grep -qi "encrypted\|passphrase"; then
              echo "‚ùå Error: Key appears to be encrypted with a passphrase"
              echo "Please provide an unencrypted private key (no passphrase)"
              exit 1
            fi
            
            # Check if it's a format issue
            if echo "$SSH_KEYGEN_ERROR" | grep -qi "invalid\|corrupt\|error in libcrypto"; then
              echo "‚ùå Error: SSH key format is invalid or corrupted"
              echo ""
              echo "Key file diagnostics:"
              echo "  - File type: $(file ~/.ssh/temp_key 2>/dev/null || echo 'unknown')"
              echo "  - File size: $(wc -c < ~/.ssh/temp_key) bytes"
              echo "  - First 50 chars (hex): $(head -c 50 ~/.ssh/temp_key | xxd -p | tr -d '\n' | head -c 100)"
              echo "  - Contains 'BEGIN': $(grep -q 'BEGIN' ~/.ssh/temp_key && echo 'Yes' || echo 'No')"
              echo "  - Contains 'PRIVATE': $(grep -q 'PRIVATE' ~/.ssh/temp_key && echo 'Yes' || echo 'No')"
              echo "  - Contains 'openssh-key-v1': $(head -c 50 ~/.ssh/temp_key | grep -q 'openssh-key-v1' && echo 'Yes' || echo 'No')"
              echo ""
              echo "The key in VM_SSH_PRIVATE_KEY_STAGING secret may be:"
              echo "  1. Corrupted during copy/paste"
              echo "  2. In an unsupported format"
              echo "  3. Double-encoded or incorrectly encoded"
              echo "  4. Missing required headers/footers"
              echo ""
              echo "Please verify the key content matches your local ~/.ssh/smartwatts_staging file exactly."
              exit 1
            fi
            
            # Unknown error - try to continue anyway (might work with SSH client)
            echo "‚ö†Ô∏è  Warning: Key validation failed with unknown error"
            echo "Attempting to continue - SSH client may still accept the key..."
          else
            echo "‚úÖ Key validation passed - can extract public key"
          fi
          
          # Try to extract public key (may fail for OpenSSH format, but that's OK)
          SSH_PUBLIC_KEY=$(ssh-keygen -y -f ~/.ssh/temp_key 2>/dev/null || echo "")
          
          if [ -n "$SSH_PUBLIC_KEY" ]; then
            echo "‚úÖ SSH public key extracted successfully"
            echo "public_key=$SSH_PUBLIC_KEY" >> $GITHUB_OUTPUT
            
            # Save public key to file
            echo "$SSH_PUBLIC_KEY" > ~/.ssh/id_rsa.pub
            chmod 644 ~/.ssh/id_rsa.pub
            echo "‚úÖ Public key saved for Bicep deployment"
          else
            echo "‚ö†Ô∏è  Warning: Could not extract SSH public key from private key"
            echo "This is OK - we'll use the key directly for SSH connections"
            echo "The VM will be created without SSH key in Bicep, but we'll add it via Azure CLI"
            echo "public_key=" >> $GITHUB_OUTPUT
          fi
          
          # Save private key for SSH connection (OpenSSH format is supported by modern SSH)
          echo "Copying key to id_rsa..."
          cp ~/.ssh/temp_key ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Verify id_rsa was created correctly
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: Failed to create ~/.ssh/id_rsa"
            exit 1
          fi
          
          ID_RSA_PERMS=$(stat -c '%a' ~/.ssh/id_rsa 2>/dev/null || stat -f '%A' ~/.ssh/id_rsa 2>/dev/null || echo "unknown")
          if [ "$ID_RSA_PERMS" != "600" ] && [ "$ID_RSA_PERMS" != "0600" ]; then
            echo "‚ö†Ô∏è  Warning: id_rsa permissions are $ID_RSA_PERMS, expected 600. Fixing..."
            chmod 600 ~/.ssh/id_rsa
            ID_RSA_PERMS=$(stat -c '%a' ~/.ssh/id_rsa 2>/dev/null || stat -f '%A' ~/.ssh/id_rsa 2>/dev/null || echo "unknown")
            echo "‚úÖ id_rsa permissions now: $ID_RSA_PERMS"
          else
            echo "‚úÖ id_rsa permissions correct: $ID_RSA_PERMS"
          fi
          
          # Verify key file is readable
          if [ ! -r ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: id_rsa is not readable"
            exit 1
          fi
          
          echo "‚úÖ SSH key setup complete"
          echo "Key file: ~/.ssh/id_rsa"
          echo "Key size: $(wc -c < ~/.ssh/id_rsa) bytes"
          echo "Key type: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          # Critical: Test if SSH can actually read the key
          echo ""
          echo "üîç Testing if SSH can read the key file..."
          SSH_TEST_OUTPUT=$(ssh-keygen -l -f ~/.ssh/id_rsa 2>&1 || echo "SSH_TEST_FAILED")
          
          if echo "$SSH_TEST_OUTPUT" | grep -qi "error\|libcrypto\|invalid\|corrupt"; then
            echo "‚ùå CRITICAL ERROR: SSH cannot read the key file"
            echo "SSH test output: $SSH_TEST_OUTPUT"
            echo ""
            echo "The key file appears to be corrupted, encrypted, or in an unsupported format."
            echo ""
            echo "Key file diagnostics:"
            echo "  - First 100 characters: $(head -c 100 ~/.ssh/id_rsa | tr -d '\n' | head -c 100)"
            echo "  - Last 100 characters: $(tail -c 100 ~/.ssh/id_rsa | tr -d '\n' | tail -c 100)"
            echo "  - Contains 'BEGIN': $(grep -q 'BEGIN' ~/.ssh/id_rsa && echo 'Yes' || echo 'No')"
            echo "  - Contains 'PRIVATE': $(grep -q 'PRIVATE' ~/.ssh/id_rsa && echo 'Yes' || echo 'No')"
            echo "  - Contains 'openssh-key-v1': $(head -c 50 ~/.ssh/id_rsa | grep -q 'openssh-key-v1' && echo 'Yes' || echo 'No')"
            echo ""
            echo "‚ùå ERROR: The SSH key in VM_SSH_PRIVATE_KEY_STAGING secret is invalid."
            echo "Please check:"
            echo "  1. The key is unencrypted (no passphrase)"
            echo "  2. The key is in PEM or OpenSSH format"
            echo "  3. The key was copied correctly (no extra spaces or line breaks)"
            echo "  4. The key is the complete private key (not just a portion)"
            exit 1
          else
            echo "‚úÖ SSH can read the key file"
            echo "Key fingerprint: $(echo "$SSH_TEST_OUTPUT" | grep -o '[a-f0-9:]*' | head -1 || echo 'N/A')"
          fi
          
          echo "‚úÖ SSH private key saved successfully"
          echo "Key file location: ~/.ssh/id_rsa"
          echo "Key file permissions: $(ls -l ~/.ssh/id_rsa | awk '{print $1}')"
          echo "Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
          echo "Key format: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          rm -f ~/.ssh/temp_key
          
      - name: Verify SSH key setup
        run: |
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ùå Error: SSH private key file not found at ~/.ssh/id_rsa"
            echo "The SSH key extraction step must have failed"
            exit 1
          fi
          
          echo "‚úÖ SSH private key file found"
          echo "Private key: ~/.ssh/id_rsa ($(stat -c%s ~/.ssh/id_rsa 2>/dev/null || stat -f%z ~/.ssh/id_rsa 2>/dev/null) bytes)"
          echo "Key format: $(file ~/.ssh/id_rsa 2>/dev/null || echo 'unknown')"
          
          # Public key is optional (may not be extractable from OpenSSH format)
          if [ -f ~/.ssh/id_rsa.pub ]; then
            echo "‚úÖ SSH public key file found"
            echo "Public key: ~/.ssh/id_rsa.pub"
            echo "Public key fingerprint: $(ssh-keygen -lf ~/.ssh/id_rsa.pub 2>/dev/null | awk '{print $2}' || echo 'N/A')"
          else
            echo "‚ö†Ô∏è  SSH public key file not found (this is OK for OpenSSH format keys)"
            echo "The key will be used directly for SSH connections"
          fi
          
          echo "‚úÖ SSH key setup verified - ready for SSH connections"

      - name: Check if Key Vault exists
        id: kvcheck
        run: |
          # Key Vault names are globally unique, so check across all resource groups
          # First try to find it in any resource group
          KV_EXISTS=$(az keyvault list --query "[?name=='sw-staging-kv'] | length(@)" -o tsv 2>/dev/null || echo "0")
          
          # Also check for soft-deleted Key Vaults
          KV_DELETED=$(az keyvault list-deleted --query "[?name=='sw-staging-kv'] | length(@)" -o tsv 2>/dev/null || echo "0")
          
          if [ "$KV_EXISTS" != "0" ] || [ "$KV_DELETED" != "0" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            if [ "$KV_DELETED" != "0" ]; then
              echo "‚ö†Ô∏è  Key Vault exists in soft-deleted state - will not create"
            else
              echo "‚úÖ Key Vault already exists globally"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "üì¶ Key Vault does not exist - will be created"
          fi

      - name: Recreate VM if SSH keys are missing
        id: vmrecreate
        if: steps.vmcheck.outputs.exists == 'true' && steps.vmsshcheck.outputs.has_ssh_keys == 'false'
        timeout-minutes: 10
        run: |
          VM_NAME="${{ env.VM_NAME }}"
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "‚ö†Ô∏è  VM exists but has no SSH keys configured"
          echo "This VM was created incorrectly and cannot be accessed via SSH"
          echo "Recreating VM with proper SSH key configuration..."
          echo ""
          echo "Note: The OS disk will be preserved (Azure keeps disks when VM is deleted)"
          echo "However, any data on the VM will be lost as we're creating a fresh VM"
          echo ""
          
          # Verify SSH public key is available before deleting VM
          if [ -z "${{ steps.sshkey.outputs.public_key }}" ]; then
            echo "‚ùå Error: Cannot recreate VM - SSH public key is not available"
            echo "The SSH key extraction step must have failed"
            echo "Please check the 'Extract SSH public key from secret' step for errors"
            exit 1
          fi
          
          echo "‚úÖ SSH public key is available - safe to recreate VM"
          echo "Public key fingerprint: $(echo '${{ steps.sshkey.outputs.public_key }}' | ssh-keygen -lf - 2>/dev/null | awk '{print $2}' || echo 'N/A')"
          echo ""
          
          # Stop VM if it's running
          VM_STATE=$(az vm show \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --show-details \
            --query "powerState" \
            -o tsv 2>/dev/null || echo "Unknown")
          
          if [ "$VM_STATE" = "VM running" ]; then
            echo "Stopping VM before deletion..."
            az vm stop \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --output none
            echo "Waiting for VM to stop..."
            sleep 10
          fi
          
          # Delete VM (OS disk will be preserved by default)
          echo "Deleting VM (OS disk will be preserved)..."
          az vm delete \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --yes \
            --output none
          
          echo "‚úÖ VM deleted successfully"
          echo "OS disk is preserved and can be reattached if needed"
          echo ""
          echo "Setting flag to recreate VM..."
          echo "recreate_vm=true" >> $GITHUB_OUTPUT

      - name: Check and Handle Active Deployments
        id: check_deployments
        timeout-minutes: 10
        run: |
          set -e
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "Checking for active deployments in resource group: $RESOURCE_GROUP"
          
          # Check for active deployments
          ACTIVE_DEPLOYMENTS=$(az deployment group list \
            --resource-group $RESOURCE_GROUP \
            --query "[?properties.provisioningState=='Running' || properties.provisioningState=='InProgress'].name" \
            -o tsv 2>/dev/null || echo "")
          
          if [ -n "$ACTIVE_DEPLOYMENTS" ]; then
            echo "‚ö†Ô∏è  Found active deployment(s):"
            # Process each deployment name
            for DEPLOYMENT_NAME in $ACTIVE_DEPLOYMENTS; do
              if [ -n "$DEPLOYMENT_NAME" ]; then
                echo "  - $DEPLOYMENT_NAME"
                
                # Get deployment details
                DEPLOYMENT_STATE=$(az deployment group show \
                  --resource-group $RESOURCE_GROUP \
                  --name "$DEPLOYMENT_NAME" \
                  --query "properties.provisioningState" \
                  -o tsv 2>/dev/null || echo "Unknown")
                
                DEPLOYMENT_START=$(az deployment group show \
                  --resource-group $RESOURCE_GROUP \
                  --name "$DEPLOYMENT_NAME" \
                  --query "properties.timestamp" \
                  -o tsv 2>/dev/null || echo "Unknown")
                
                echo "    State: $DEPLOYMENT_STATE"
                echo "    Started: $DEPLOYMENT_START"
                
                # If deployment is active, poll for completion instead of using wait command
                if [ "$DEPLOYMENT_STATE" = "Running" ] || [ "$DEPLOYMENT_STATE" = "InProgress" ]; then
                  echo "    ‚è≥ Polling for deployment completion (max 10 minutes)..."
                  MAX_WAIT=600
                  ELAPSED=0
                  POLL_INTERVAL=15
                  
                  while [ $ELAPSED -lt $MAX_WAIT ]; do
                    CURRENT_STATE=$(az deployment group show \
                      --resource-group $RESOURCE_GROUP \
                      --name "$DEPLOYMENT_NAME" \
                      --query "properties.provisioningState" \
                      -o tsv 2>/dev/null || echo "Unknown")
                    
                    if [ "$CURRENT_STATE" = "Succeeded" ]; then
                      echo "    ‚úÖ Deployment '$DEPLOYMENT_NAME' completed successfully"
                      break
                    elif [ "$CURRENT_STATE" = "Failed" ] || [ "$CURRENT_STATE" = "Canceled" ]; then
                      echo "    ‚ö†Ô∏è  Deployment '$DEPLOYMENT_NAME' ended with state: $CURRENT_STATE"
                      # Show error details if available
                      ERROR_DETAILS=$(az deployment group show \
                        --resource-group $RESOURCE_GROUP \
                        --name "$DEPLOYMENT_NAME" \
                        --query "properties.error.message" \
                        -o tsv 2>/dev/null || echo "")
                      if [ -n "$ERROR_DETAILS" ]; then
                        echo "    Error: $ERROR_DETAILS"
                      fi
                      break
                    elif [ "$CURRENT_STATE" != "Running" ] && [ "$CURRENT_STATE" != "InProgress" ]; then
                      echo "    ‚ÑπÔ∏è  Deployment '$DEPLOYMENT_NAME' state: $CURRENT_STATE"
                      break
                    fi
                    
                    echo "    ‚è≥ Still running... (${ELAPSED}s elapsed, state: $CURRENT_STATE)"
                    sleep $POLL_INTERVAL
                    ELAPSED=$((ELAPSED + POLL_INTERVAL))
                  done
                  
                  # If still running after max wait, cancel it
                  FINAL_STATE=$(az deployment group show \
                    --resource-group $RESOURCE_GROUP \
                    --name "$DEPLOYMENT_NAME" \
                    --query "properties.provisioningState" \
                    -o tsv 2>/dev/null || echo "Unknown")
                  
                  if [ "$FINAL_STATE" = "Running" ] || [ "$FINAL_STATE" = "InProgress" ]; then
                    echo "    ‚ö†Ô∏è  Deployment '$DEPLOYMENT_NAME' is stuck, cancelling..."
                    az deployment group cancel \
                      --resource-group $RESOURCE_GROUP \
                      --name "$DEPLOYMENT_NAME" \
                      --output none 2>/dev/null || echo "    ‚ö†Ô∏è  Could not cancel (may have already completed/failed)"
                    sleep 5
                  fi
                fi
              fi
            done
            
            # Verify no active deployments remain
            sleep 5
            REMAINING_ACTIVE=$(az deployment group list \
              --resource-group $RESOURCE_GROUP \
              --query "[?properties.provisioningState=='Running' || properties.provisioningState=='InProgress'].name" \
              -o tsv 2>/dev/null || echo "")
            
            if [ -n "$REMAINING_ACTIVE" ]; then
              echo "‚ö†Ô∏è  Warning: Some deployments may still be active, but proceeding with new deployment"
            else
              echo "‚úÖ No active deployments remaining"
            fi
          else
            echo "‚úÖ No active deployments found"
          fi

      - name: Check if Infrastructure Deployment is Needed
        id: check_deployment
        run: |
          set -e
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          VM_NAME="${{ env.VM_NAME }}"
          
          echo "Checking if infrastructure deployment is needed..."
          
          # Check if VM exists with SSH keys
          VM_EXISTS=false
          VM_HAS_SSH_KEYS=false
          
          if [ "${{ steps.vmcheck.outputs.exists }}" = "true" ]; then
            VM_EXISTS=true
            if [ "${{ steps.vmsshcheck.outputs.has_ssh_keys }}" = "true" ]; then
              VM_HAS_SSH_KEYS=true
              echo "‚úÖ VM exists with SSH keys configured"
            else
              echo "‚ö†Ô∏è  VM exists but without SSH keys - deployment needed"
            fi
          else
            echo "üì¶ VM does not exist - deployment needed"
          fi
          
          # Check if Key Vault exists
          KEY_VAULT_EXISTS=false
          if [ "${{ steps.kvcheck.outputs.exists }}" = "true" ]; then
            KEY_VAULT_EXISTS=true
            echo "‚úÖ Key Vault exists"
          else
            echo "üì¶ Key Vault does not exist - deployment needed"
          fi
          
          # Determine if deployment is needed
          NEEDS_DEPLOYMENT=false
          
          # Deployment is needed if:
          # 1. VM doesn't exist
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ]; then
            NEEDS_DEPLOYMENT=true
            echo "Reason: VM does not exist"
          # 2. VM is being recreated
          elif [ "${{ steps.vmrecreate.outputs.recreate_vm }}" = "true" ]; then
            NEEDS_DEPLOYMENT=true
            echo "Reason: VM is being recreated"
          # 3. VM exists but has no SSH keys (will be recreated)
          elif [ "${{ steps.vmcheck.outputs.exists }}" = "true" ] && [ "${{ steps.vmsshcheck.outputs.has_ssh_keys }}" = "false" ]; then
            NEEDS_DEPLOYMENT=true
            echo "Reason: VM exists but has no SSH keys"
          # 4. Key Vault doesn't exist and needs to be created
          elif [ "${{ steps.kvcheck.outputs.exists }}" = "false" ]; then
            NEEDS_DEPLOYMENT=true
            echo "Reason: Key Vault does not exist"
          else
            # All infrastructure exists and is properly configured
            NEEDS_DEPLOYMENT=false
            echo "‚úÖ All infrastructure already exists and is properly configured"
            echo "   - VM exists with SSH keys"
            echo "   - Key Vault exists"
            echo "   - No deployment needed"
          fi
          
          if [ "$NEEDS_DEPLOYMENT" = "true" ]; then
            echo "needs_deployment=true" >> $GITHUB_OUTPUT
            echo "üöÄ Infrastructure deployment is needed"
          else
            echo "needs_deployment=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  Skipping infrastructure deployment - all resources already exist"
          fi

      - name: Deploy Infrastructure via Bicep
        if: steps.check_deployment.outputs.needs_deployment == 'true'
        id: deploy
        timeout-minutes: 20
        run: |
          set -e
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          # Determine if we should deploy SSH extension (only for new VMs)
          DEPLOY_SSH_EXTENSION=false
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ]; then
            DEPLOY_SSH_EXTENSION=true
          elif [ "${{ steps.vmrecreate.outputs.recreate_vm }}" = "true" ]; then
            DEPLOY_SSH_EXTENSION=true
          fi
          
          # Use unique deployment name to avoid conflicts
          # Format: main-YYYYMMDD-HHMMSS-{short-commit-sha}
          DEPLOYMENT_NAME="main-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA:0:7}"
          echo "Using deployment name: $DEPLOYMENT_NAME"
          
          DEPLOY_CMD="az deployment group create \
            --resource-group $RESOURCE_GROUP \
            --name $DEPLOYMENT_NAME \
            --template-file ${{ env.TEMPLATE_FILE }} \
            --parameters @${{ env.PARAM_FILE }} \
            --parameters vmAdminPassword=\"${{ secrets.VM_ADMIN_PASSWORD_STAGING }}\" \
            --parameters createKeyVault=$([ "${{ steps.kvcheck.outputs.exists }}" = "true" ] && echo "false" || echo "true") \
            --parameters deploySshExtension=$([ "$DEPLOY_SSH_EXTENSION" = "true" ] && echo "true" || echo "false") \
            --mode Incremental \
            --no-wait"

          # Pass SSH key if:
          # 1. VM doesn't exist, OR
          # 2. VM is being recreated (was deleted because it had no SSH keys), OR
          # 3. VM exists but has no SSH keys (will be recreated in next step)
          NEEDS_SSH_KEY=false
          if [ "${{ steps.vmcheck.outputs.exists }}" = "false" ]; then
            NEEDS_SSH_KEY=true
            echo "VM not found. Will create with SSH key."
          elif [ "${{ steps.vmrecreate.outputs.recreate_vm }}" = "true" ]; then
            NEEDS_SSH_KEY=true
            echo "VM was recreated. Will create with SSH key."
          elif [ "${{ steps.vmsshcheck.outputs.has_ssh_keys }}" = "false" ]; then
            NEEDS_SSH_KEY=true
            echo "VM exists but has no SSH keys. Will recreate with SSH key."
          fi
          
          if [ "$NEEDS_SSH_KEY" = "true" ]; then
            if [ -n "${{ steps.sshkey.outputs.public_key }}" ]; then
              echo "Injecting SSH key for VM creation."
              DEPLOY_CMD="$DEPLOY_CMD --parameters vmSshPublicKey=\"${{ steps.sshkey.outputs.public_key }}\""
              echo "‚úÖ Adding SSH public key to Bicep deployment"
              echo "Public key fingerprint: $(echo '${{ steps.sshkey.outputs.public_key }}' | ssh-keygen -lf - 2>/dev/null | awk '{print $2}' || echo 'N/A')"
            else
              echo "‚ùå Error: SSH public key is required for VM creation but is not available"
              echo "The SSH key extraction step must have failed"
              echo "Please check the 'Extract SSH public key from secret' step for errors"
              exit 1
            fi
          else
            echo "VM already exists with SSH keys. Skipping vmSshPublicKey parameter (Azure doesn't allow updating SSH keys via Bicep)."
          fi

          echo "Starting deployment (async mode to prevent hanging)..."
          eval "$DEPLOY_CMD"
          
          echo "Deployment started, monitoring progress..."
          MAX_WAIT=840  # 14 minutes (leaving 1 minute buffer before timeout)
          ELAPSED=0
          POLL_INTERVAL=30
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            DEPLOYMENT_STATE=$(az deployment group show \
              --resource-group $RESOURCE_GROUP \
              --name $DEPLOYMENT_NAME \
              --query "properties.provisioningState" \
              -o tsv 2>/dev/null || echo "Unknown")
            
            if [ "$DEPLOYMENT_STATE" = "Succeeded" ]; then
              echo "‚úÖ Deployment completed successfully"
              break
            elif [ "$DEPLOYMENT_STATE" = "Failed" ]; then
              echo "‚ùå Deployment failed"
              # Get error details
              ERROR=$(az deployment group show \
                --resource-group $RESOURCE_GROUP \
                --name $DEPLOYMENT_NAME \
                --query "properties.error" \
                -o json 2>/dev/null || echo "{}")
              echo "Error details: $ERROR"
              exit 1
            elif [ "$DEPLOYMENT_STATE" = "Canceled" ]; then
              echo "‚ö†Ô∏è  Deployment was canceled"
              exit 1
            elif [ "$DEPLOYMENT_STATE" = "Unknown" ]; then
              echo "‚ö†Ô∏è  Could not get deployment state, waiting..."
            else
              echo "‚è≥ Deployment in progress... State: $DEPLOYMENT_STATE (${ELAPSED}s elapsed)"
            fi
            
            sleep $POLL_INTERVAL
            ELAPSED=$((ELAPSED + POLL_INTERVAL))
          done
          
          # Final check
          FINAL_STATE=$(az deployment group show \
            --resource-group $RESOURCE_GROUP \
            --name $DEPLOYMENT_NAME \
            --query "properties.provisioningState" \
            -o tsv 2>/dev/null || echo "Unknown")
          
          if [ "$FINAL_STATE" != "Succeeded" ]; then
            echo "‚ùå Deployment did not complete successfully. Final state: $FINAL_STATE"
            if [ "$FINAL_STATE" = "Running" ] || [ "$FINAL_STATE" = "InProgress" ]; then
              echo "‚ö†Ô∏è  Deployment is still running but timed out. It will continue in the background."
              echo "You can check status with: az deployment group show --resource-group $RESOURCE_GROUP --name $DEPLOYMENT_NAME"
            fi
            exit 1
          fi

      - name: Skip Infrastructure Deployment
        if: steps.check_deployment.outputs.needs_deployment == 'false'
        run: |
          echo "‚è≠Ô∏è  Infrastructure deployment skipped"
          echo ""
          echo "All required infrastructure already exists:"
          echo "  ‚úÖ VM: ${{ env.VM_NAME }} exists with SSH keys"
          if [ "${{ steps.kvcheck.outputs.exists }}" = "true" ]; then
            echo "  ‚úÖ Key Vault: sw-staging-kv exists"
          fi
          echo ""
          echo "No changes needed. Proceeding to application deployment..."

      - name: Wait for VM Agent and Verify SSH Service
        timeout-minutes: 5
        if: steps.vmcheck.outputs.exists == 'false' || steps.vmrecreate.outputs.recreate_vm == 'true' || (steps.vmcheck.outputs.exists == 'true' && steps.vmsshcheck.outputs.has_ssh_keys == 'false')
        run: |
          VM_NAME="${{ env.VM_NAME }}"
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "Waiting for VM agent to be ready after creation..."
          MAX_WAIT=300
          ELAPSED=0
          VM_AGENT_READY=false
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Check VM agent status
            AGENT_STATUS=$(az vm show \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --instance-view \
              --query "instanceView.vmAgent.statuses[?code=='ProvisioningState/succeeded']" \
              -o json 2>/dev/null || echo "[]")
            
            if echo "$AGENT_STATUS" | grep -q "succeeded"; then
              echo "‚úÖ VM agent is ready"
              VM_AGENT_READY=true
              break
            fi
            
            echo "Waiting for VM agent... ($ELAPSED/$MAX_WAIT seconds)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ "$VM_AGENT_READY" = "false" ]; then
            echo "‚ö†Ô∏è  Warning: VM agent may not be fully ready, but continuing..."
          fi
          
          # Wait for custom script extension to complete
          echo "Waiting for SSH service configuration extension to complete..."
          sleep 30
          
          # Verify SSH service is running using VM run-command
          echo "Verifying SSH service is running..."
          SSH_CHECK=$(az vm run-command invoke \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --command-id RunShellScript \
            --scripts "systemctl is-active sshd || systemctl is-active ssh || echo 'inactive'" \
            --query "value[0].message" -o tsv 2>/dev/null | grep -v "Enable" || echo "unknown")
          
          if echo "$SSH_CHECK" | grep -qi "active\|running"; then
            echo "‚úÖ SSH service is running"
          else
            echo "‚ö†Ô∏è  Warning: SSH service status unclear: $SSH_CHECK"
            echo "Attempting to start SSH service..."
            az vm run-command invoke \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --command-id RunShellScript \
              --scripts "sudo systemctl start sshd || sudo systemctl start ssh || sudo service ssh start || sudo service sshd start" \
              --output none 2>/dev/null || echo "Failed to start SSH service"
            sleep 10
          fi
          
          # Verify SSH keys are actually configured on the VM
          echo ""
          echo "Verifying SSH keys are configured on the VM..."
          VM_SSH_KEYS=$(az vm show \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --query "osProfile.linuxConfiguration.ssh.publicKeys" \
            -o json 2>/dev/null || echo "[]")
          
          if [ "$VM_SSH_KEYS" = "[]" ] || [ "$VM_SSH_KEYS" = "null" ] || [ -z "$VM_SSH_KEYS" ]; then
            echo "‚ùå Error: VM was created but SSH keys are not configured!"
            echo "This should not happen - the Bicep template should have configured SSH keys"
            echo "VM SSH keys status: $VM_SSH_KEYS"
            exit 1
          else
            echo "‚úÖ SSH keys are properly configured on the VM"
            KEY_COUNT=$(echo "$VM_SSH_KEYS" | jq 'length' 2>/dev/null || echo "1")
            echo "Number of SSH keys configured: $KEY_COUNT"
          fi

      - name: Retrieve VM Public IP
        id: get_ip
        run: |
          VM_IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.PUBLIC_IP_NAME }} \
            --query "ipAddress" -o tsv)
          echo "VM_IP=$VM_IP" >> $GITHUB_ENV
          echo "VM IP: $VM_IP"

      - name: Update VM SSH key (if VM already existed)
        if: steps.vmcheck.outputs.exists == 'true' && steps.sshkey.outputs.public_key != ''
        run: |
          echo "Updating VM authorized_keys using Azure CLI..."
          if az vm user update \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.VM_NAME }} \
            --username ${{ env.VM_ADMIN_USERNAME }} \
            --ssh-key-value "${{ steps.sshkey.outputs.public_key }}" 2>&1; then
            echo "‚úÖ SSH key updated successfully"
            echo "Waiting 30 seconds for key to propagate..."
            sleep 30
          else
            echo "‚ö†Ô∏è Warning: Failed to update SSH key via Azure CLI"
            echo "You may need to manually add the SSH key or recreate the VM"
          fi

      - name: Check and Start VM
        timeout-minutes: 5
        run: |
          VM_NAME="${{ env.VM_NAME }}"
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "Checking VM state..."
          VM_STATE=$(az vm show \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --show-details \
            --query "powerState" \
            -o tsv 2>/dev/null || echo "Unknown")
          
          echo "VM State: $VM_STATE"
          
          if [ "$VM_STATE" = "VM deallocated" ] || [ "$VM_STATE" = "VM stopped" ]; then
            echo "‚ö†Ô∏è  VM is stopped. Starting VM..."
            az vm start \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --output none
            
            echo "Waiting for VM to be fully started..."
            MAX_WAIT=300
            ELAPSED=0
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CURRENT_STATE=$(az vm show \
                --resource-group $RESOURCE_GROUP \
                --name $VM_NAME \
                --show-details \
                --query "powerState" \
                -o tsv 2>/dev/null || echo "Unknown")
              
              if [ "$CURRENT_STATE" = "VM running" ]; then
                echo "‚úÖ VM is running"
                echo "Waiting additional 30 seconds for SSH service to be ready..."
                sleep 30
                break
              fi
              
              echo "VM state: $CURRENT_STATE (waiting...)"
              sleep 10
              ELAPSED=$((ELAPSED + 10))
            done
            
            if [ "$CURRENT_STATE" != "VM running" ]; then
              echo "‚ö†Ô∏è  Warning: VM may not be fully started, but continuing..."
            fi
          elif [ "$VM_STATE" = "VM running" ]; then
            echo "‚úÖ VM is already running"
          else
            echo "‚ö†Ô∏è  Warning: VM state is '$VM_STATE' (unexpected)"
          fi

      - name: Check and Fix SSH Service
        timeout-minutes: 5
        continue-on-error: true
        run: |
          VM_NAME="${{ env.VM_NAME }}"
          RESOURCE_GROUP="${{ env.AZURE_RESOURCE_GROUP }}"
          
          echo "Checking SSH service status on VM using Azure VM run-command..."
          
          # Check if SSH service is running
          SSH_CHECK_SCRIPT='systemctl is-active sshd || systemctl is-active ssh || echo "inactive"'
          SSH_STATUS=$(az vm run-command invoke \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --command-id RunShellScript \
            --scripts "$SSH_CHECK_SCRIPT" \
            --query "value[0].message" -o tsv 2>/dev/null | grep -v "Enable" || echo "unknown")
          
          echo "SSH service status: $SSH_STATUS"
          
          if echo "$SSH_STATUS" | grep -qi "inactive\|failed\|unknown"; then
            echo "‚ö†Ô∏è  SSH service is not running. Attempting to start it..."
            
            # Start SSH service
            az vm run-command invoke \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --command-id RunShellScript \
              --scripts "sudo systemctl start sshd || sudo systemctl start ssh || sudo service ssh start || sudo service sshd start" \
              --output none 2>/dev/null || echo "Failed to start SSH service via run-command"
            
            echo "Waiting 10 seconds for SSH service to start..."
            sleep 10
            
            # Enable SSH service to start on boot
            az vm run-command invoke \
              --resource-group $RESOURCE_GROUP \
              --name $VM_NAME \
              --command-id RunShellScript \
              --scripts "sudo systemctl enable sshd || sudo systemctl enable ssh" \
              --output none 2>/dev/null || true
            
            echo "‚úÖ SSH service start command issued"
          else
            echo "‚úÖ SSH service appears to be running"
          fi
          
          # Verify SSH is listening on port 22
          echo "Verifying SSH is listening on port 22..."
          PORT_CHECK=$(az vm run-command invoke \
            --resource-group $RESOURCE_GROUP \
            --name $VM_NAME \
            --command-id RunShellScript \
            --scripts "sudo netstat -tlnp | grep ':22 ' || sudo ss -tlnp | grep ':22 ' || echo 'SSH not listening'" \
            --query "value[0].message" -o tsv 2>/dev/null | grep -v "Enable" || echo "")
          
          if echo "$PORT_CHECK" | grep -q "22"; then
            echo "‚úÖ SSH is listening on port 22"
          else
            echo "‚ö†Ô∏è  Warning: SSH may not be listening on port 22"
            echo "Port check output: $PORT_CHECK"
          fi

      - name: Verify SSH Connection
        timeout-minutes: 5
        continue-on-error: true
        run: |
          MAX_RETRIES=5
          RETRY_DELAY=15
          COUNT=0

          echo "Verifying SSH connection to ${{ env.VM_IP }}..."
          
          # Check NSG rules
          echo "Checking NSG rules for SSH access..."
          NSG_NAME=$(az network nsg list --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[?contains(name, 'nsg')].name" -o tsv | head -1)
          if [ -n "$NSG_NAME" ]; then
            echo "NSG: $NSG_NAME"
            az network nsg rule list --nsg-name "$NSG_NAME" --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query "[?destinationPortRange=='22']" -o table || echo "Could not list NSG rules"
          fi
          
          # Check if SSH service is accessible
          echo "Testing SSH port connectivity..."
          timeout 5 bash -c "echo > /dev/tcp/${{ env.VM_IP }}/22" 2>/dev/null && echo "‚úÖ Port 22 is open" || echo "‚ö†Ô∏è  Port 22 may be blocked or SSH service not running"
          
          # Add VM to known_hosts (non-blocking)
          ssh-keyscan -H ${{ env.VM_IP }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add VM to known_hosts (will continue)"

          # Verify SSH key file exists
          if [ ! -f ~/.ssh/id_rsa ]; then
            echo "‚ö†Ô∏è  Warning: SSH private key file not found at ~/.ssh/id_rsa"
            echo "SSH connection will likely fail. Continuing anyway..."
          else
            echo "‚úÖ SSH private key file found"
            # Test SSH connection with longer timeout and retry logic
            SSH_SUCCESS=false
            while [ $COUNT -lt $MAX_RETRIES ]; do
              echo "SSH connection attempt $((COUNT + 1)) of $MAX_RETRIES..."
              if ssh -i ~/.ssh/id_rsa \
                -o StrictHostKeyChecking=no \
                -o UserKnownHostsFile=/dev/null \
                -o ConnectTimeout=30 \
                -o ServerAliveInterval=10 \
                -o ServerAliveCountMax=3 \
                -o BatchMode=yes \
                ${{ env.VM_ADMIN_USERNAME }}@${{ env.VM_IP }} 'echo "SSH connection successful"' 2>&1; then
                SSH_SUCCESS=true
                break
              else
                echo "SSH attempt $((COUNT + 1)) failed"
                COUNT=$((COUNT + 1))
                if [ $COUNT -lt $MAX_RETRIES ]; then
                  echo "Waiting $RETRY_DELAY seconds before retry..."
                  sleep $RETRY_DELAY
                fi
              fi
            done
          fi

          if [ "$SSH_SUCCESS" != "true" ]; then
            echo "‚ö†Ô∏è  SSH connection verification failed after $MAX_RETRIES attempts."
            echo "VM IP: ${{ env.VM_IP }}"
            echo "VM State: $(az vm show -d --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query powerState -o tsv 2>/dev/null || echo 'unknown')"
            echo ""
            echo "‚ö†Ô∏è  Warning: SSH connection failed. Deployment will continue, but manual intervention may be required."
            echo "To fix SSH access:"
            echo "1. Check if SSH key was added: az vm show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --query 'osProfile.linuxConfiguration.ssh.publicKeys'"
            echo "2. Try adding SSH key manually: az vm user update --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.VM_NAME }} --username ${{ env.VM_ADMIN_USERNAME }} --ssh-key-value \"<public-key>\""
            echo "3. Or use Azure Portal to reset SSH key"
            echo ""
            echo "‚ö†Ô∏è  Continuing deployment despite SSH failure..."
          else
            echo "‚úÖ SSH connection verified successfully!"
          fi

      - name: Check if Repository Exists on VM
        timeout-minutes: 2
        continue-on-error: true
        run: |
          VM_IP="${{ env.VM_IP }}"
          CHECK_SCRIPT='if [ -d "/home/azureuser/SmartWatts" ] || [ -d "/home/azureuser/smartwatts" ]; then echo "EXISTS"; else echo "NOT_FOUND"; fi'
          REPO_STATUS=$(ssh -o StrictHostKeyChecking=no \
                         -o UserKnownHostsFile=/dev/null \
                         -o ConnectTimeout=30 \
                         -o ServerAliveInterval=10 \
                         -o ServerAliveCountMax=3 \
                         -i ~/.ssh/id_rsa \
                         azureuser@$VM_IP "$CHECK_SCRIPT" 2>/dev/null || echo "NOT_FOUND")
          echo "REPO_STATUS=$REPO_STATUS" >> $GITHUB_ENV
          if [ "$REPO_STATUS" = "EXISTS" ]; then
            echo "‚úÖ Repository already exists on VM, skipping copy/extract steps"
          else
            if [ "$REPO_STATUS" = "NOT_FOUND" ]; then
              echo "‚ö†Ô∏è  Could not verify repository status (SSH may have failed). Assuming repository needs to be copied."
              echo "REPO_STATUS=NOT_FOUND" >> $GITHUB_ENV
            else
              echo "üì¶ Repository not found, will copy and extract"
            fi
          fi

      - name: Copy Repository to VM
        timeout-minutes: 5
        if: env.REPO_STATUS != 'EXISTS'
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=5
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Copying repository to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            if scp -o StrictHostKeyChecking=no \
                   -o UserKnownHostsFile=/dev/null \
                   -o ConnectTimeout=30 \
                   -o ServerAliveInterval=10 \
                   -o ServerAliveCountMax=3 \
                   -i ~/.ssh/id_rsa \
                   -r ./* azureuser@$VM_IP:/tmp/smartwatts.tar.gz; then
              echo "Repository copied successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Copy failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "Error: Failed to copy repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Extract repository on VM
        timeout-minutes: 5
        if: env.REPO_STATUS != 'EXISTS'
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Extracting repository on VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            EXTRACT_SCRIPT=$(printf 'cd /home/azureuser\nif [ -d "smartwatts" ]; then\n  rm -rf smartwatts\nfi\nmkdir -p smartwatts\ncd smartwatts\ntar xzf /tmp/smartwatts.tar.gz\nrm /tmp/smartwatts.tar.gz\necho "Repository extracted successfully"')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=30 \
                 -o ServerAliveInterval=10 \
                 -o ServerAliveCountMax=3 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$EXTRACT_SCRIPT"; then
              echo "Repository extracted successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Extraction failed, retrying in $((RETRY_COUNT * 5)) seconds..."
                sleep $((RETRY_COUNT * 5))
              else
                echo "Error: Failed to extract repository after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Deploy Application to VM
        timeout-minutes: 60
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Deploying application to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            DEPLOY_SCRIPT=$(printf '%s\n' \
              'if ! command -v docker &> /dev/null; then' \
              '  echo "Installing Docker...";' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq ca-certificates curl gnupg lsb-release || true;' \
              '  sudo mkdir -p /etc/apt/keyrings;' \
              '  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg;' \
              '  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null;' \
              '  sudo apt-get update -qq;' \
              '  sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {' \
              '    echo "Docker CE installation failed, trying docker.io...";' \
              '    sudo apt-get install -y -qq docker.io docker-compose || { echo "Error: Docker installation failed"; exit 1; };' \
              '  };' \
              '  if ! command -v docker &> /dev/null; then' \
              '    echo "Error: Docker installation failed - docker command not found";' \
              '    exit 1;' \
              '  fi;' \
              '  if getent group docker > /dev/null 2>&1; then sudo usermod -aG docker $USER; fi;' \
              '  echo "Docker installed successfully";' \
              'fi;' \
              'if systemctl list-unit-files | grep -q docker.service; then' \
              '  sudo systemctl start docker || true;' \
              '  sudo systemctl enable docker || true;' \
              'else' \
              '  if ! sudo docker info > /dev/null 2>&1; then' \
              '    echo "Warning: Docker service not found, but Docker may still work";' \
              '    sudo dockerd > /dev/null 2>&1 &' \
              '    sleep 5;' \
              '  fi;' \
              'fi;' \
              'if ! sudo docker info > /dev/null 2>&1; then' \
              '  echo "Error: Docker daemon is not running";' \
              '  exit 1;' \
              'fi;' \
              'echo "Docker is installed and running";' \
              'DOCKER_COMPOSE_CMD="";' \
              'if command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1; then' \
              '  DOCKER_COMPOSE_CMD="docker compose";' \
              '  echo "Using Docker Compose plugin (docker compose)";' \
              'elif command -v docker-compose &> /dev/null; then' \
              '  DOCKER_COMPOSE_CMD="docker-compose";' \
              '  echo "Using docker-compose command";' \
              'elif [ -f /usr/local/bin/docker-compose ]; then' \
              '  DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose";' \
              '  echo "Using docker-compose from /usr/local/bin";' \
              'else' \
              '  echo "Installing docker-compose...";' \
              '  sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose;' \
              '  sudo chmod +x /usr/local/bin/docker-compose;' \
              '  DOCKER_COMPOSE_CMD="/usr/local/bin/docker-compose";' \
              '  echo "docker-compose installed to /usr/local/bin";' \
              'fi;' \
              'if [ -z "$DOCKER_COMPOSE_CMD" ]; then' \
              '  echo "ERROR: Could not find or install docker-compose";' \
              '  exit 1;' \
              'fi;' \
              'REPO_DIR="";' \
              'if [ -d "/home/azureuser/SmartWatts" ]; then' \
              '  REPO_DIR="/home/azureuser/SmartWatts";' \
              'elif [ -d "/home/azureuser/smartwatts" ]; then' \
              '  REPO_DIR="/home/azureuser/smartwatts";' \
              'else' \
              '  echo "Error: Repository not found. Expected /home/azureuser/SmartWatts or /home/azureuser/smartwatts";' \
              '  exit 1;' \
              'fi;' \
              'cd "$REPO_DIR";' \
              'echo "Using repository at: $REPO_DIR";' \
              'echo "Verifying Gradle wrapper files exist...";' \
              'MISSING_FILES=0;' \
              'for service_dir in backend/*-service backend/*-gateway backend/service-discovery; do' \
              '  if [ -d "$service_dir" ]; then' \
              '    if [ ! -f "$service_dir/gradle/wrapper/gradle-wrapper.jar" ]; then' \
              '      echo "ERROR: Missing gradle-wrapper.jar in $service_dir";' \
              '      MISSING_FILES=$((MISSING_FILES + 1));' \
              '    else' \
              '      echo "‚úì Found gradle-wrapper.jar in $service_dir";' \
              '    fi;' \
              '  fi;' \
              'done;' \
              'if [ $MISSING_FILES -gt 0 ]; then' \
              '  echo "ERROR: $MISSING_FILES service(s) missing gradle-wrapper.jar files";' \
              '  echo "Listing backend directory structure:";' \
              '  find backend -name "gradle-wrapper.jar" -type f || echo "No gradle-wrapper.jar files found";' \
              '  exit 1;' \
              'fi;' \
              'echo "All Gradle wrapper files verified successfully";' \
              'cd azure-deployment;' \
              'export POSTGRES_PASSWORD="${POSTGRES_PASSWORD:-SmartWatts2024!}";' \
              'echo "Starting Docker Compose services using: $DOCKER_COMPOSE_CMD";' \
              'if echo "$DOCKER_COMPOSE_CMD" | grep -q "docker compose"; then' \
              '  if ! sudo docker compose -f docker-compose.azure.yml up -d --build; then' \
              '    echo "ERROR: Docker Compose failed to start services";' \
              '    echo "Container logs:";' \
              '    sudo docker compose -f docker-compose.azure.yml logs --tail=50 || true;' \
              '    exit 1;' \
              '  fi;' \
              '  COMPOSE_CMD="docker compose";' \
              'else' \
              '  if ! sudo $DOCKER_COMPOSE_CMD -f docker-compose.azure.yml up -d --build; then' \
              '    echo "ERROR: Docker Compose failed to start services";' \
              '    echo "Container logs:";' \
              '    sudo $DOCKER_COMPOSE_CMD -f docker-compose.azure.yml logs --tail=50 || true;' \
              '    exit 1;' \
              '  fi;' \
              '  COMPOSE_CMD="$DOCKER_COMPOSE_CMD";' \
              'fi;' \
              'echo "Starting Docker Compose build (this may take 20-40 minutes for first build)...";' \
              'echo "Note: Gradle builds for all services can take significant time";' \
              'if echo "$COMPOSE_CMD" | grep -q "docker compose"; then' \
              '  if ! sudo docker compose -f docker-compose.azure.yml up -d --build; then' \
              '    echo "ERROR: Docker Compose build failed";' \
              '    echo "Container logs:";' \
              '    sudo docker compose -f docker-compose.azure.yml logs --tail=50 || true;' \
              '    exit 1;' \
              '  fi;' \
              'else' \
              '  if ! sudo $COMPOSE_CMD -f docker-compose.azure.yml up -d --build; then' \
              '    echo "ERROR: Docker Compose build failed";' \
              '    echo "Container logs:";' \
              '    sudo $COMPOSE_CMD -f docker-compose.azure.yml logs --tail=50 || true;' \
              '    exit 1;' \
              '  fi;' \
              'fi;' \
              'echo "Docker Compose build completed successfully";' \
              'echo "Waiting for containers to be ready...";' \
              'MAX_WAIT=600;' \
              'ELAPSED=0;' \
              'ALL_READY=false;' \
              'while [ $ELAPSED -lt $MAX_WAIT ]; do' \
              '  if echo "$COMPOSE_CMD" | grep -q "docker compose"; then' \
              '    CONTAINER_STATUS=$(sudo docker compose -f docker-compose.azure.yml ps --format json 2>/dev/null || echo "[]");' \
              '  else' \
              '    CONTAINER_STATUS=$(sudo $COMPOSE_CMD -f docker-compose.azure.yml ps --format json 2>/dev/null || echo "[]");' \
              '  fi;' \
              '  TOTAL_CONTAINERS=$(echo "$CONTAINER_STATUS" | grep -c "Name" || echo "0");' \
              '  RUNNING_CONTAINERS=$(echo "$CONTAINER_STATUS" | grep -c '"'"'"State":"running"'"'"' || echo "0");' \
              '  if [ "$TOTAL_CONTAINERS" -gt 0 ] && [ "$RUNNING_CONTAINERS" -eq "$TOTAL_CONTAINERS" ]; then' \
              '    echo "All $RUNNING_CONTAINERS containers are running";' \
              '    sleep 10;' \
              '    if command -v nc > /dev/null 2>&1 || command -v netcat > /dev/null 2>&1; then' \
              '      NC_CMD=$(command -v nc || command -v netcat);' \
              '      BACKEND_READY=false;' \
              '      FRONTEND_READY=false;' \
              '      if timeout 2 $NC_CMD -z localhost 8080 2>/dev/null; then' \
              '        BACKEND_READY=true;' \
              '        echo "Backend port 8080 is listening";' \
              '      fi;' \
              '      if timeout 2 $NC_CMD -z localhost 3000 2>/dev/null; then' \
              '        FRONTEND_READY=true;' \
              '        echo "Frontend port 3000 is listening";' \
              '      fi;' \
              '      if [ "$BACKEND_READY" = "true" ] && [ "$FRONTEND_READY" = "true" ]; then' \
              '        ALL_READY=true;' \
              '        break;' \
              '      fi;' \
              '    else' \
              '      echo "netcat not available, checking container health instead...";' \
              '      HEALTHY_COUNT=$(sudo docker ps --filter "health=healthy" --format "{{.Names}}" | wc -l);' \
              '      if [ "$HEALTHY_COUNT" -ge 2 ]; then' \
              '        ALL_READY=true;' \
              '        break;' \
              '      fi;' \
              '    fi;' \
              '  fi;' \
              '  echo "Waiting for services... ($ELAPSED/$MAX_WAIT seconds)";' \
              '  sleep 10;' \
              '  ELAPSED=$((ELAPSED + 10));' \
              'done;' \
              'if [ "$ALL_READY" = "true" ]; then' \
              '  echo "‚úÖ All services are ready";' \
              '  if echo "$COMPOSE_CMD" | grep -q "docker compose"; then' \
              '    sudo docker compose -f docker-compose.azure.yml ps;' \
              '  else' \
              '    sudo $COMPOSE_CMD -f docker-compose.azure.yml ps;' \
              '  fi;' \
              '  echo "Application deployed successfully";' \
              'else' \
              '  echo "‚ö†Ô∏è  Warning: Services started but may not be fully ready";' \
              '  echo "Container status:";' \
              '  if echo "$COMPOSE_CMD" | grep -q "docker compose"; then' \
              '    sudo docker compose -f docker-compose.azure.yml ps;' \
              '    echo "Recent logs:";' \
              '    sudo docker compose -f docker-compose.azure.yml logs --tail=30;' \
              '  else' \
              '    sudo $COMPOSE_CMD -f docker-compose.azure.yml ps;' \
              '    echo "Recent logs:";' \
              '    sudo $COMPOSE_CMD -f docker-compose.azure.yml logs --tail=30;' \
              '  fi;' \
              '  echo "Application deployment completed (services may still be initializing)";' \
              'fi')
            if ssh -o StrictHostKeyChecking=no \
                 -o UserKnownHostsFile=/dev/null \
                 -o ConnectTimeout=30 \
                 -o ServerAliveInterval=10 \
                 -o ServerAliveCountMax=3 \
                 -i ~/.ssh/id_rsa \
                 azureuser@$VM_IP "$DEPLOY_SCRIPT"; then
              echo "Application deployed successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Deployment failed, retrying in $((RETRY_COUNT * 10)) seconds..."
                sleep $((RETRY_COUNT * 10))
              else
                echo "Error: Failed to deploy application after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Check if Static Web App exists
        id: swacheck
        continue-on-error: true
        run: |
          STATIC_APP_NAME="sw-staging-dashboard"
          if az staticwebapp show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name $STATIC_APP_NAME >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Static Web App found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Static Web App '$STATIC_APP_NAME' not found"
          fi
          
          if [ -z "${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}" ]; then
            echo "token_set=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Warning: AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING secret is not set"
          else
            echo "token_set=true" >> $GITHUB_OUTPUT
            echo "‚úÖ API token is set"
          fi

      - name: Deploy Frontend to Static Web Apps
        timeout-minutes: 10
        if: steps.swacheck.outputs.exists == 'true' && steps.swacheck.outputs.token_set == 'true'
        continue-on-error: true
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "frontend"
          output_location: ".next"
          skip_app_build: false
          skip_api_build: true

      - name: Get Deployment Outputs
        run: |
          echo "VM Public IP: ${{ env.VM_IP }}"
          echo "Static Web App URL: $(az staticwebapp show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-staging-dashboard \
            --query defaultHostname -o tsv 2>/dev/null || echo 'Not available')"

      - name: Health Check
        timeout-minutes: 10
        run: |
          VM_IP="${{ env.VM_IP }}"
          MAX_RETRIES=20
          RETRY_COUNT=0
          WAIT_INTERVAL=15
          
          echo "Performing health checks..."
          echo "  - Backend API: http://$VM_IP:8080/api/v1/health"
          echo "  - Frontend: http://$VM_IP:3000"
          echo "  - Frontend (via Nginx): http://$VM_IP"
          echo ""
          echo "Note: Services should already be ready (deployment step waits for readiness)"
          echo "Starting health checks immediately..."
          
          BACKEND_HEALTHY=false
          FRONTEND_HEALTHY=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo ""
            echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            
            # Check Backend API
            if [ "$BACKEND_HEALTHY" = "false" ]; then
              CURL_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" http://$VM_IP:8080/api/v1/health 2>&1 || echo "CURL_ERROR")
              BACKEND_STATUS=$(echo "$CURL_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
              
              if [ "$BACKEND_STATUS" = "200" ]; then
                echo "‚úÖ Backend API is healthy (HTTP 200)"
                BACKEND_HEALTHY=true
              else
                echo "‚ö†Ô∏è  Backend API not responding (HTTP $BACKEND_STATUS)"
              fi
            fi
            
            # Check Frontend (port 3000)
            if [ "$FRONTEND_HEALTHY" = "false" ]; then
              FRONTEND_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" http://$VM_IP:3000 2>&1 || echo "CURL_ERROR")
              FRONTEND_STATUS=$(echo "$FRONTEND_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
              
              if [ "$FRONTEND_STATUS" = "200" ] || [ "$FRONTEND_STATUS" = "301" ] || [ "$FRONTEND_STATUS" = "302" ]; then
                echo "‚úÖ Frontend is accessible on port 3000 (HTTP $FRONTEND_STATUS)"
                FRONTEND_HEALTHY=true
              else
                echo "‚ö†Ô∏è  Frontend not responding on port 3000 (HTTP $FRONTEND_STATUS)"
              fi
            fi
            
            # Check Frontend via Nginx (port 80)
            NGINX_OUTPUT=$(curl -s -w "\nHTTP_CODE:%{http_code}\n" http://$VM_IP 2>&1 || echo "CURL_ERROR")
            NGINX_STATUS=$(echo "$NGINX_OUTPUT" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
            if [ "$NGINX_STATUS" = "200" ] || [ "$NGINX_STATUS" = "301" ] || [ "$NGINX_STATUS" = "302" ]; then
              echo "‚úÖ Frontend accessible via Nginx on port 80 (HTTP $NGINX_STATUS)"
            else
              echo "‚ö†Ô∏è  Nginx not responding on port 80 (HTTP $NGINX_STATUS)"
            fi
            
            if [ "$BACKEND_HEALTHY" = "true" ] && [ "$FRONTEND_HEALTHY" = "true" ]; then
              echo ""
              echo "‚úÖ All health checks passed!"
              echo "   Frontend: http://$VM_IP:3000 or http://$VM_IP"
              echo "   Backend API: http://$VM_IP:8080"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              if [ "$BACKEND_STATUS" = "000" ]; then
                echo "‚ö†Ô∏è  Health check failed (HTTP $BACKEND_STATUS) - Connection refused or service not running"
                if [ $RETRY_COUNT -eq 1 ]; then
                  echo "Diagnostics:"
                  echo "  - Checking if port 8080 is accessible..."
                  timeout 3 bash -c "echo > /dev/tcp/$VM_IP/8080" 2>/dev/null && echo "    ‚úÖ Port 8080 is open" || echo "    ‚ùå Port 8080 is not accessible"
                  echo "  - This may be normal if the application hasn't been deployed yet (SSH may have failed)"
                fi
              else
                echo "Health check failed, retrying in $WAIT_INTERVAL seconds..."
              fi
              
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep $WAIT_INTERVAL
              else
                echo "‚ùå Error: Health checks failed after $MAX_RETRIES attempts"
                echo "   Backend API: HTTP $BACKEND_STATUS"
                echo "   Frontend: HTTP $FRONTEND_STATUS"
                echo ""
                echo "Possible reasons:"
                echo "  1. Application deployment failed (check SSH connection and deployment logs above)"
                echo "  2. Application is still starting up (may need more time)"
                echo "  3. Port 8080 is not accessible (check NSG rules and firewall)"
                echo "  4. Application crashed or failed to start"
                echo ""
                echo "‚ùå Health check failed - workflow will fail"
                echo "Please check the VM and application deployment status."
                exit 1
              fi
            fi
          done
          
          # If we reach here, health checks failed
          echo ""
          echo "‚ùå Error: Health checks failed - maximum retries reached"
          echo "   Backend API: $([ "$BACKEND_HEALTHY" = "true" ] && echo "‚úÖ Healthy" || echo "‚ùå Not responding")"
          echo "   Frontend: $([ "$FRONTEND_HEALTHY" = "true" ] && echo "‚úÖ Healthy" || echo "‚ùå Not responding")"
          echo ""
          echo "Please check the VM and application deployment status."
          exit 1

      - name: Post-Deployment Summary
        run: |
          echo "‚úÖ Deployment completed."
          echo "VM IP: ${{ env.VM_IP }}"
          echo "Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          echo "Deployment Name: main"
