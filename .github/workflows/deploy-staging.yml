name: Deploy Staging (main branch)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-staging-rg
  ENVIRONMENT: staging
  LOCATION: westeurope

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_STAGING }}

    - name: Create Resource Group
      run: |
        az group create \
          --name ${{ env.AZURE_RESOURCE_GROUP }} \
          --location ${{ env.LOCATION }} \
          --output none

    - name: Register Required Resource Providers
      run: |
        az provider register --namespace microsoft.operationalinsights --wait
        az provider register --namespace microsoft.devices --wait
        az provider register --namespace microsoft.storage --wait
        az provider register --namespace microsoft.web --wait
        az provider register --namespace microsoft.keyvault --wait
        az provider register --namespace microsoft.network --wait

    - name: Cancel Stuck Deployments
      run: |
        echo "Checking for active deployments named 'main'..."
        # Try to cancel the 'main' deployment if it exists and is active
        az deployment group cancel \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name main 2>/dev/null && echo "Cancelled stuck deployment 'main'" || echo "No active deployment 'main' to cancel (or already completed)"
        # Wait a moment for cancellation to process
        sleep 5

    - name: Deploy Infrastructure (Bicep)
      run: |
        az deployment group create \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --template-file infrastructure/bicep/main.bicep \
          --parameters @infrastructure/bicep/params.staging.json \
          --parameters vmAdminPassword="${{ secrets.VM_ADMIN_PASSWORD_STAGING }}"

    - name: Get VM Public IP
      id: get-vm-ip
      run: |
        VM_IP=$(az vm show -d \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-staging-vm \
          --query publicIps -o tsv)
        echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT

    - name: Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        # Write SSH private key - decode from base64 if needed
        SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_STAGING }}"
        # Check if key starts with BEGIN marker (plain text PEM format)
        if echo "$SSH_KEY" | head -c 20 | grep -q "BEGIN"; then
          # Key is already in plain text PEM format
          echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/id_rsa
        else
          # Key appears to be base64 encoded - decode it
          echo "$SSH_KEY" | base64 -d > ~/.ssh/id_rsa
        fi
        chmod 600 ~/.ssh/id_rsa
        # Check key format and convert to PEM if needed
        KEY_START=$(head -c 20 ~/.ssh/id_rsa | xxd -p | tr -d '\n')
        # Check if key is in DER format (starts with 30 82 - ASN.1 SEQUENCE)
        if echo "$KEY_START" | grep -q "^3082"; then
          echo "Key is in DER format - converting to PEM format"
          # Convert DER to PEM using openssl
          openssl rsa -inform DER -in ~/.ssh/id_rsa -outform PEM -out ~/.ssh/id_rsa.pem 2>/dev/null && mv ~/.ssh/id_rsa.pem ~/.ssh/id_rsa || {
            echo "Warning: Could not convert DER key to PEM format, trying ssh-keygen"
            # Try using ssh-keygen to convert
            cp ~/.ssh/id_rsa ~/.ssh/id_rsa.der
            ssh-keygen -p -N "" -m PEM -f ~/.ssh/id_rsa.der > /dev/null 2>&1 && mv ~/.ssh/id_rsa.der ~/.ssh/id_rsa || {
              echo "Error: Could not convert DER key to PEM format"
              exit 1
            }
          }
        elif head -c 15 ~/.ssh/id_rsa | grep -q "openssh-key-v1"; then
          echo "Key is in OpenSSH format - converting to PEM format"
          # Convert OpenSSH format to PEM format (no passphrase change, just format conversion)
          ssh-keygen -p -N "" -m PEM -f ~/.ssh/id_rsa > /dev/null 2>&1 || {
            echo "Warning: Could not convert OpenSSH key to PEM format, trying to use as-is"
          }
        fi
        # Verify key can be read by ssh-keygen
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          # Try extracting public key as alternative validation
          if ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub 2>/dev/null; then
            echo "SSH key validated by extracting public key"
          else
            echo "Error: SSH key cannot be read by ssh-keygen"
            echo "Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
            echo "Number of lines: $(wc -l < ~/.ssh/id_rsa)"
            echo "First 50 characters (hex):"
            head -c 50 ~/.ssh/id_rsa | xxd | head -n 3
            exit 1
          fi
        else
          echo "SSH key validated successfully"
          # Extract public key
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
        fi
        ssh-keyscan -H ${{ steps.get-vm-ip.outputs.vm_ip }} >> ~/.ssh/known_hosts
        # Add public key to VM using Azure CLI
        echo "Adding public key to VM..."
        az vm user update \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-staging-vm \
          --username azureuser \
          --ssh-key-value "$(cat ~/.ssh/id_rsa.pub)" 2>&1 || {
          echo "Note: Could not add public key via Azure CLI, will add via SSH during deployment"
        }
        # Also add public key directly via Azure VM run-command as fallback
        echo "Adding public key to VM authorized_keys via Azure run-command (fallback)..."
        PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)
        az vm run-command invoke \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-staging-vm \
          --command-id RunShellScript \
          --scripts "sudo -u azureuser bash -c 'mkdir -p ~/.ssh && chmod 700 ~/.ssh && echo \"$PUBLIC_KEY\" >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys'" 2>&1 || echo "Note: Could not add public key via run-command (may already exist)"

    - name: Copy Repository to VM
      run: |
        # Create tarball of repository
        tar czf /tmp/smartwatts.tar.gz --exclude='.git' --exclude='node_modules' --exclude='.next' .
        # Copy repository to VM
        scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa /tmp/smartwatts.tar.gz azureuser@${{ steps.get-vm-ip.outputs.vm_ip }}:/tmp/
        # Extract repository on VM
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa azureuser@${{ steps.get-vm-ip.outputs.vm_ip }} << 'EOF'
          cd /home/azureuser
          if [ -d "smartwatts" ]; then
            rm -rf smartwatts
          fi
          mkdir -p smartwatts
          cd smartwatts
          tar xzf /tmp/smartwatts.tar.gz
          rm /tmp/smartwatts.tar.gz
        EOF

    - name: Deploy Application to VM
      timeout-minutes: 30
      run: |
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa azureuser@${{ steps.get-vm-ip.outputs.vm_ip }} << 'EOF'
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            # Use apt-get to install Docker (more reliable for Ubuntu 20.04)
            sudo apt-get update -qq
            sudo apt-get install -y -qq \
              ca-certificates \
              curl \
              gnupg \
              lsb-release || true
            
            # Add Docker's official GPG key
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            
            # Set up Docker repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
              $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Install Docker
            sudo apt-get update -qq
            sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {
              echo "Docker CE installation failed, trying docker.io..."
              sudo apt-get install -y -qq docker.io docker-compose || {
                echo "Error: Docker installation failed"
                exit 1
              }
            }
            
            # Verify Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Error: Docker installation failed - docker command not found"
              exit 1
            fi
            
            # Add user to docker group (only if group exists)
            if getent group docker > /dev/null 2>&1; then
              sudo usermod -aG docker $USER
            fi
            echo "Docker installed successfully"
          fi
          
          # Start Docker service if not running
          # Check if Docker service exists before trying to start it
          if systemctl list-unit-files | grep -q docker.service; then
            sudo systemctl start docker || true
            sudo systemctl enable docker || true
          else
            # If service doesn't exist, try starting dockerd directly or check if Docker is already running
            if ! sudo docker info > /dev/null 2>&1; then
              echo "Warning: Docker service not found, but Docker may still work"
              # Try to start Docker daemon manually
              sudo dockerd > /dev/null 2>&1 &
              sleep 5
            fi
          fi
          
          # Verify Docker is working
          if ! sudo docker info > /dev/null 2>&1; then
            echo "Error: Docker daemon is not running"
            exit 1
          fi
          echo "Docker is installed and running"
          
          # Install Docker Compose if not present
          if ! command -v docker-compose &> /dev/null && ! (command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1); then
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          
          # Navigate to repository
          cd /home/azureuser/smartwatts
          
          # Verify Gradle wrapper files exist before building
          echo "Verifying Gradle wrapper files exist..."
          MISSING_FILES=0
          for service_dir in backend/*-service backend/*-gateway backend/service-discovery; do
            if [ -d "$service_dir" ]; then
              if [ ! -f "$service_dir/gradle/wrapper/gradle-wrapper.jar" ]; then
                echo "ERROR: Missing gradle-wrapper.jar in $service_dir"
                MISSING_FILES=$((MISSING_FILES + 1))
              else
                echo "âœ“ Found gradle-wrapper.jar in $service_dir"
              fi
            fi
          done
          
          if [ $MISSING_FILES -gt 0 ]; then
            echo "ERROR: $MISSING_FILES service(s) missing gradle-wrapper.jar files"
            echo "Listing backend directory structure:"
            find backend -name "gradle-wrapper.jar" -type f || echo "No gradle-wrapper.jar files found"
            exit 1
          fi
          
          echo "All Gradle wrapper files verified successfully"
          
          # Clean up Docker resources to prevent network exhaustion
          echo "Cleaning up Docker resources..."
          sudo docker system prune -f || true
          sudo docker network prune -f || true
          sudo docker container prune -f || true
          
          # Stop any existing containers to free up resources
          cd azure-deployment
          sudo docker-compose -f docker-compose.azure.yml down || true
          
          # Wait a moment for resources to be released
          sleep 5
          
          # Deploy with Docker Compose (use sudo since group membership may not be active)
          # Retry logic for network resource issues
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Disable BuildKit to reduce network resource usage
            export DOCKER_BUILDKIT=0
            export COMPOSE_DOCKER_CLI_BUILD=0
            
            echo "=== Starting Docker Compose build (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES) ==="
            echo "Timestamp: $(date)"
            
            # Build with progress logging
            if timeout 1800 sudo docker-compose -f docker-compose.azure.yml build --progress=plain 2>&1 | tee /tmp/docker-build.log; then
              echo "=== Build completed successfully ==="
              echo "Timestamp: $(date)"
              
              # Start containers
              echo "=== Starting containers ==="
              if sudo docker-compose -f docker-compose.azure.yml up -d; then
                echo "Docker Compose build and start succeeded"
                break
              else
                echo "ERROR: Failed to start containers"
                RETRY_COUNT=$((RETRY_COUNT + 1))
              fi
            else
              echo "ERROR: Build failed or timed out after 30 minutes"
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Build failed, cleaning up and retrying (attempt $RETRY_COUNT/$MAX_RETRIES)..."
              sudo docker-compose -f docker-compose.azure.yml down || true
              sudo docker system prune -f || true
              sudo docker network prune -f || true
              sleep 10
            else
              echo "Build failed after $MAX_RETRIES attempts"
              echo "Last 50 lines of build log:"
              tail -50 /tmp/docker-build.log || true
              exit 1
            fi
          done
        EOF

    - name: Deploy Frontend to Static Web Apps
      uses: Azure/static-web-apps-deploy@v1
      with:
        azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_STAGING }}
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        action: "upload"
        app_location: "frontend"
        output_location: ".next"
        skip_app_build: false
        skip_api_build: true

    - name: Get Deployment Outputs
      run: |
        echo "VM Public IP: ${{ steps.get-vm-ip.outputs.vm_ip }}"
        echo "Static Web App URL: $(az staticwebapp show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-staging-dashboard \
          --query defaultHostname -o tsv)"

    - name: Health Check
      run: |
        sleep 60  # Wait for services to start
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        curl -f http://$VM_IP:8080/actuator/health || exit 1

