# Docs for the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
# More GitHub Actions for Azure: https://github.com/Azure/actions

name: Build and deploy Node.js app to Azure Web App - SmartWatts

# Automatic runs on push to main branch + manual trigger
on:
  push:
    branches:
      - main
  workflow_dispatch:  # Can also trigger manually via GitHub Actions UI

env:
  # VM_IP can be set as a repository variable, defaults to staging VM IP in script if not set
  VM_IP: ${{ vars.VM_IP }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read #This is required for actions/checkout

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js version
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          cache: 'npm'
          cache-dependency-path: './frontend/package-lock.json'
      
      - name: Cache Next.js build and SWC binaries
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/next-swc
            ${{ github.workspace }}/frontend/.next/cache
            ${{ github.workspace }}/frontend/node_modules/.cache
          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-
            ${{ runner.os }}-nextjs-

      - name: npm install, build, and test
        working-directory: ./frontend
        env:
          NEXT_TELEMETRY_DISABLED: 1
          NODE_OPTIONS: "--max-old-space-size=4096"
        run: |
          echo "=== Clearing all caches first ==="
          rm -rf .next
          rm -rf ~/.cache/next-swc
          rm -rf node_modules/.cache
          npm cache clean --force
          
          echo "=== Installing dependencies ==="
          npm ci --prefer-offline --no-audit
          
          echo ""
          echo "=== Building Next.js application (with proper validation) ==="
          MAX_RETRIES=3
          RETRY_COUNT=0
          BUILD_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo ""
            echo "Build attempt $RETRY_COUNT/$MAX_RETRIES..."
            
            # Clear corrupted caches before retry
            if [ $RETRY_COUNT -gt 1 ]; then
              echo "Clearing corrupted caches before retry..."
              rm -rf .next
              rm -rf ~/.cache/next-swc
              rm -rf node_modules/.cache
              npm cache clean --force
              
              # Reinstall Next.js and related packages if bus error occurred
              if grep -qi "Bus error\|core dumped" /tmp/build.log 2>/dev/null; then
                echo "Bus error detected - reinstalling Next.js dependencies..."
                npm uninstall next @next/swc-linux-x64-gnu 2>/dev/null || true
                npm install next --force
              fi
              
              echo "Waiting 5 seconds for cache cleanup..."
              sleep 5
            fi
            
            # Run build and capture all output
            set +e  # Don't exit on error
            npm run build 2>&1 | tee /tmp/build.log
            BUILD_EXIT_CODE=$?
            set -e
            
            echo ""
            echo "Build process completed with exit code: $BUILD_EXIT_CODE"
            
            # Check for errors in the logs (even if exit code was 0)
            if grep -qi "unhandledRejection\|ZlibError\|TAR_ABORT\|FATAL ERROR\|Bus error\|core dumped" /tmp/build.log; then
              echo "‚ö†Ô∏è  Build log contains fatal errors (attempt $RETRY_COUNT)"
              
              # Check if standalone was created despite errors
              if [ -d ".next/standalone" ]; then
                echo "‚úÖ Standalone directory exists despite warnings - build may have recovered"
                BUILD_SUCCESS=true
                break
              else
                echo "‚ùå Standalone directory not created - build failed"
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Retrying in 10 seconds..."
                  sleep 10
                fi
              fi
            elif [ $BUILD_EXIT_CODE -ne 0 ]; then
              echo "‚ö†Ô∏è  Build failed with exit code $BUILD_EXIT_CODE (attempt $RETRY_COUNT)"
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Retrying in 10 seconds..."
                sleep 10
              fi
            else
              # Exit code 0 and no fatal errors - verify standalone exists
              if [ -d ".next/standalone" ]; then
                echo "‚úÖ Build succeeded on attempt $RETRY_COUNT"
                BUILD_SUCCESS=true
                break
              else
                echo "‚ö†Ô∏è  Build exited cleanly but standalone directory missing (attempt $RETRY_COUNT)"
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Retrying in 10 seconds..."
                  sleep 10
                fi
              fi
            fi
          done
          
          if [ "$BUILD_SUCCESS" = "false" ]; then
            echo ""
            echo "‚ùå Build failed after $MAX_RETRIES attempts"
            echo ""
            echo "Last build log:"
            tail -100 /tmp/build.log
            echo ""
            echo ".next directory contents:"
            ls -la .next/ 2>/dev/null || echo ".next directory not found"
            exit 1
          fi
          
          # Tests temporarily disabled
          # npm run test --if-present
          
          echo ""
          echo "=== Verifying standalone build ==="
          if [ ! -d ".next/standalone" ]; then
            echo "‚ùå Error: .next/standalone directory not found after build"
            echo "This means standalone mode is not working correctly"
            echo "Checking next.config.js..."
            cat next.config.js | grep -i "output" || echo "No output config found"
            echo "Build output:"
            ls -la .next/ 2>/dev/null || echo ".next directory not found"
            exit 1
          fi
          
          echo "‚úÖ Standalone build verified"
          echo "Standalone directory contents:"
          ls -la .next/standalone/ | head -10

      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: node-app
          path: |
            ./frontend/.next/standalone
            ./frontend/.next/static
            ./frontend/public
          retention-days: 1

  deploy:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      id-token: write #This is required for requesting the JWT
      contents: read #This is required for actions/checkout

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: node-app
          path: ./artifact
      
      - name: Prepare deployment package for standalone mode
        run: |
          echo "üì¶ Preparing Next.js standalone deployment package..."
          
          # Check artifact structure (GitHub Actions preserves path structure)
          echo "Checking artifact structure..."
          find artifact -type d -maxdepth 3 2>/dev/null | head -20 || echo "Artifact directory not found"
          
          # Find standalone directory (could be at different paths depending on how artifact was uploaded)
          STANDALONE_DIR=$(find artifact -type d -name "standalone" 2>/dev/null | head -1 || echo "")
          
          if [ -z "$STANDALONE_DIR" ]; then
            echo "‚ùå Error: .next/standalone directory not found in artifact"
            echo "Artifact contents:"
            ls -la artifact/ 2>/dev/null || echo "Artifact directory not found"
            find artifact -type d 2>/dev/null | head -20 || echo "No directories found"
            exit 1
          fi
          
          echo "‚úÖ Found standalone directory at: $STANDALONE_DIR"
          
          # Find static directory
          STATIC_DIR=$(find artifact -type d -path "*/static" 2>/dev/null | head -1 || echo "")
          if [ -z "$STATIC_DIR" ]; then
            echo "‚ö†Ô∏è  Warning: .next/static directory not found"
          else
            echo "‚úÖ Found static directory at: $STATIC_DIR"
          fi
          
          # Find public directory
          PUBLIC_DIR=$(find artifact -type d -name "public" 2>/dev/null | head -1 || echo "")
          if [ -z "$PUBLIC_DIR" ]; then
            echo "‚ö†Ô∏è  Warning: public directory not found"
          else
            echo "‚úÖ Found public directory at: $PUBLIC_DIR"
          fi
          
          # Create deployment directory
          mkdir -p deploy-package
          
          # Copy standalone output
          echo "Copying standalone files from $STANDALONE_DIR..."
          cp -r "$STANDALONE_DIR"/* deploy-package/
          
          # Copy static files
          if [ -n "$STATIC_DIR" ]; then
            echo "Copying static files from $STATIC_DIR..."
            mkdir -p deploy-package/.next/static
            cp -r "$STATIC_DIR"/* deploy-package/.next/static/
          fi
          
          # Copy public directory
          if [ -n "$PUBLIC_DIR" ]; then
            echo "Copying public files from $PUBLIC_DIR..."
            cp -r "$PUBLIC_DIR" deploy-package/
          fi
          
          # Check if package.json exists in standalone (it should)
          if [ -f "$STANDALONE_DIR/package.json" ]; then
            echo "‚úÖ package.json found in standalone build"
          else
            echo "‚ö†Ô∏è  Warning: package.json not found in standalone build"
            echo "This may cause Azure to not detect this as a Node.js app"
            echo "Checking if we need to copy it from source..."
            # Try to find package.json in artifact
            PKG_JSON=$(find artifact -name "package.json" -type f 2>/dev/null | head -1 || echo "")
            if [ -n "$PKG_JSON" ]; then
              echo "Found package.json at: $PKG_JSON"
              cp "$PKG_JSON" deploy-package/package.json
              echo "‚úÖ Copied package.json to deployment package"
            fi
          fi
          
          # Verify server.js exists
          if [ ! -f "deploy-package/server.js" ]; then
            echo "‚ùå Error: server.js not found in standalone output"
            echo "Deployment package contents:"
            ls -la deploy-package/ | head -20
            exit 1
          fi
          
          echo "‚úÖ Deployment package prepared"
          echo "Contents:"
          ls -la deploy-package/ | head -20
          echo ""
          echo "Verifying server.js:"
          head -5 deploy-package/server.js || echo "Could not read server.js"
      
      - name: Verify deployment package structure
        run: |
          echo "üîç Verifying deployment package structure..."
          
          # Check critical files
          MISSING_FILES=0
          
          if [ ! -f "deploy-package/server.js" ]; then
            echo "‚ùå Error: server.js not found"
            MISSING_FILES=$((MISSING_FILES + 1))
          else
            echo "‚úÖ server.js found"
            # Check if it's executable or at least readable
            if [ ! -r "deploy-package/server.js" ]; then
              echo "‚ö†Ô∏è  Warning: server.js is not readable"
            fi
          fi
          
          if [ ! -d "deploy-package/.next/static" ]; then
            echo "‚ö†Ô∏è  Warning: .next/static directory not found"
          else
            echo "‚úÖ .next/static directory found"
          fi
          
          if [ ! -d "deploy-package/public" ]; then
            echo "‚ö†Ô∏è  Warning: public directory not found (may be optional)"
          else
            echo "‚úÖ public directory found"
          fi
          
          # Check for node_modules (should exist in standalone)
          if [ ! -d "deploy-package/node_modules" ]; then
            echo "‚ö†Ô∏è  Warning: node_modules directory not found in standalone build"
            echo "This may cause runtime errors"
          else
            echo "‚úÖ node_modules directory found"
          fi
          
          # Check package.json (may be needed for Node.js detection)
          if [ ! -f "deploy-package/package.json" ]; then
            echo "‚ö†Ô∏è  Warning: package.json not found in deployment package"
            echo "Azure may have trouble detecting this as a Node.js app"
          else
            echo "‚úÖ package.json found"
          fi
          
          if [ $MISSING_FILES -gt 0 ]; then
            echo "‚ùå Error: Critical files missing in deployment package"
            echo "Deployment package structure:"
            find deploy-package -type f -name "*.js" | head -10
            find deploy-package -type d | head -10
            exit 1
          fi
          
          echo "‚úÖ Deployment package structure verified"
          echo "Package size: $(du -sh deploy-package | awk '{print $1}')"
          echo "File count: $(find deploy-package -type f | wc -l)"
      
      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_577CA716950C4C849FCD8534DB68F666 }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_E0A871202B5249189A79EA035FBEB0E8 }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_07BBF5665D464E728201D26286D736CD }}

      - name: Configure Azure Web App for standalone mode
        run: |
          APP_NAME="SmartWatts"
          RESOURCE_GROUP=$(az webapp show --name $APP_NAME --query resourceGroup -o tsv 2>/dev/null || echo "")
          
          if [ -z "$RESOURCE_GROUP" ]; then
            RESOURCE_GROUP=$(az webapp list --query "[?name=='$APP_NAME'].resourceGroup" -o tsv 2>/dev/null | head -1 || echo "")
          fi
          
          if [ -n "$RESOURCE_GROUP" ]; then
            echo "‚öôÔ∏è  Configuring Azure Web App for Next.js standalone mode..."
            
            # Check web app state and start if stopped (using -o tsv instead of jq)
            echo "Checking web app state..."
            STATE=$(az webapp show \
              --resource-group $RESOURCE_GROUP \
              --name $APP_NAME \
              --query state \
              -o tsv 2>/dev/null || echo "Unknown")
            
            USAGE_STATE=$(az webapp show \
              --resource-group $RESOURCE_GROUP \
              --name $APP_NAME \
              --query properties.usageState \
              -o tsv 2>/dev/null || echo "Unknown")
            
            echo "Web app state: $STATE"
            echo "Usage state: $USAGE_STATE"
            
            if [ "$STATE" = "Stopped" ]; then
              echo "‚ö†Ô∏è  Web app is stopped. Starting it now..."
              az webapp start \
                --resource-group $RESOURCE_GROUP \
                --name $APP_NAME \
                --output none
              echo "‚úÖ Web app start command issued"
              
              # Wait for web app to be fully ready (can take 30-60 seconds)
              echo "‚è≥ Waiting for web app to be fully ready for deployment..."
              MAX_WAIT=120
              ELAPSED=0
              while [ $ELAPSED -lt $MAX_WAIT ]; do
                CURRENT_STATE=$(az webapp show \
                  --resource-group $RESOURCE_GROUP \
                  --name $APP_NAME \
                  --query state \
                  -o tsv 2>/dev/null || echo "Unknown")
                
                if [ "$CURRENT_STATE" = "Running" ]; then
                  # Verify it's actually enabled and ready
                  ENABLED=$(az webapp show \
                    --resource-group $RESOURCE_GROUP \
                    --name $APP_NAME \
                    --query enabled \
                    -o tsv 2>/dev/null || echo "false")
                  
                  if [ "$ENABLED" = "true" ]; then
                    echo "‚úÖ Web app is running and enabled (ready for deployment)"
                    break
                  else
                    echo "   Web app is Running but not Enabled yet..."
                  fi
                fi
                
                echo "   State: $CURRENT_STATE (${ELAPSED}s elapsed)..."
                sleep 5
                ELAPSED=$((ELAPSED + 5))
              done
              
              if [ $ELAPSED -ge $MAX_WAIT ]; then
                echo "‚ö†Ô∏è  Warning: Web app may not be fully ready, but proceeding with deployment"
              fi
            elif [ "$USAGE_STATE" = "Exceeded" ]; then
              echo "‚ö†Ô∏è  Warning: Web app usage state is 'Exceeded' (quota exceeded)"
              echo "Attempting to start the app anyway..."
              az webapp start \
                --resource-group $RESOURCE_GROUP \
                --name $APP_NAME \
                --output none 2>/dev/null || echo "Could not start app (quota issue may need manual resolution)"
              echo "‚ö†Ô∏è  Note: Quota issues need to be resolved in the Azure Portal"
            elif [ "$STATE" = "Running" ]; then
              echo "‚úÖ Web app is already running"
            else
              echo "‚ö†Ô∏è  Web app state is '$STATE' - attempting to start..."
              az webapp start \
                --resource-group $RESOURCE_GROUP \
                --name $APP_NAME \
                --output none 2>/dev/null || echo "Could not start app"
            fi
            
            # Set startup command to use node server.js
            echo "Setting startup file to 'node server.js'..."
            az webapp config set \
              --resource-group $RESOURCE_GROUP \
              --name $APP_NAME \
              --startup-file "node server.js" \
              --output none
            
            # Verify startup file was set
            STARTUP_FILE=$(az webapp config show \
              --resource-group $RESOURCE_GROUP \
              --name $APP_NAME \
              --query appCommandLine \
              -o tsv 2>/dev/null || echo "")
            
            if [ "$STARTUP_FILE" = "node server.js" ]; then
              echo "‚úÖ Startup file verified: $STARTUP_FILE"
            else
              echo "‚ö†Ô∏è  Warning: Startup file may not be set correctly. Got: '$STARTUP_FILE'"
            fi
            
            # Disable build during deployment
            # Set environment variables for frontend to connect to VM backend
            # Use GitHub environment variable or default to staging VM IP
            VM_IP="${{ env.VM_IP }}"
            if [ -z "$VM_IP" ]; then
              VM_IP="52.182.155.148"  # Default to staging VM IP
            fi
            az webapp config appsettings set \
              --resource-group $RESOURCE_GROUP \
              --name $APP_NAME \
              --settings \
                SCM_DO_BUILD_DURING_DEPLOYMENT=false \
                ENABLE_ORYX_BUILD=false \
                POST_BUILD_COMMAND="" \
                PRE_BUILD_COMMAND="" \
                NEXT_PUBLIC_API_URL="http://${VM_IP}:8080" \
                NEXT_PUBLIC_WS_URL="ws://${VM_IP}:8080" \
                NODE_ENV="production" \
              --output none
            
            echo "‚úÖ Environment variables configured:"
            echo "   NEXT_PUBLIC_API_URL=http://${VM_IP}:8080"
            echo "   NEXT_PUBLIC_WS_URL=ws://${VM_IP}:8080"
            
            echo "‚úÖ Azure Web App configured for standalone mode"
          else
            echo "‚ö†Ô∏è  Could not determine resource group, skipping configuration"
          fi

      - name: Check for active deployments
        id: check-deployment
        continue-on-error: true
        run: |
          APP_NAME="SmartWatts"
          
          # Try multiple methods to find the resource group
          RESOURCE_GROUP=$(az webapp show --name $APP_NAME --query resourceGroup -o tsv 2>/dev/null || echo "")
          
          # If that fails, try searching for the web app
          if [ -z "$RESOURCE_GROUP" ]; then
            echo "‚ö†Ô∏è  Could not get resource group from webapp show, trying alternative method..."
            RESOURCE_GROUP=$(az webapp list --query "[?name=='$APP_NAME'].resourceGroup" -o tsv 2>/dev/null | head -1 || echo "")
          fi
          
          if [ -z "$RESOURCE_GROUP" ]; then
            echo "‚ö†Ô∏è  Could not determine resource group for web app '$APP_NAME'"
            echo "Skipping active deployment check (web app may not exist yet)"
            echo "active=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "‚úÖ Found resource group: $RESOURCE_GROUP"
          
          echo "Checking for active deployments in resource group: $RESOURCE_GROUP"
          
          # Check for active deployments
          ACTIVE_DEPLOYMENTS=$(az webapp deployment list \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query "[?status=='Running' || status=='InProgress'].id" \
            -o tsv 2>/dev/null || echo "")
          
          if [ -n "$ACTIVE_DEPLOYMENTS" ]; then
            echo "‚ö†Ô∏è  Active deployment(s) found, waiting for completion..."
            echo "active=true" >> $GITHUB_OUTPUT
            
            # Wait for active deployments to complete (max 10 minutes)
            MAX_WAIT=600
            ELAPSED=0
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              ACTIVE=$(az webapp deployment list \
                --resource-group $RESOURCE_GROUP \
                --name $APP_NAME \
                --query "[?status=='Running' || status=='InProgress'].id" \
                -o tsv 2>/dev/null || echo "")
              
              if [ -z "$ACTIVE" ]; then
                echo "‚úÖ All active deployments completed"
                echo "active=false" >> $GITHUB_OUTPUT
                break
              fi
              
              echo "‚è≥ Waiting for deployment to complete... (${ELAPSED}s elapsed)"
              sleep 10
              ELAPSED=$((ELAPSED + 10))
            done
            
            if [ $ELAPSED -ge $MAX_WAIT ]; then
              echo "‚ö†Ô∏è  Warning: Timeout waiting for active deployments, proceeding anyway"
            fi
          else
            echo "‚úÖ No active deployments found"
            echo "active=false" >> $GITHUB_OUTPUT
          fi

      - name: Verify web app is ready before deployment
        run: |
          APP_NAME="SmartWatts"
          
          echo "üîç Verifying web app exists and is ready for deployment..."
          
          # First, verify we can find the web app
          WEB_APP_JSON=$(az webapp show --name $APP_NAME --output json 2>&1 || echo "")
          
          if echo "$WEB_APP_JSON" | grep -qi "not found\|does not exist"; then
            echo "‚ùå Error: Web app '$APP_NAME' does not exist"
            echo ""
            echo "Please create the web app first:"
            echo "  az webapp create --resource-group <resource-group> --name $APP_NAME --plan <app-service-plan> --runtime \"NODE|20\""
            exit 1
          fi
          
          # Extract resource group from the JSON output
          RESOURCE_GROUP=$(echo "$WEB_APP_JSON" | grep -o '"resourceGroup"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4 || echo "")
          
          if [ -z "$RESOURCE_GROUP" ]; then
            # Fallback: try direct query
            RESOURCE_GROUP=$(az webapp show --name $APP_NAME --query resourceGroup -o tsv 2>/dev/null || echo "")
          fi
          
          if [ -z "$RESOURCE_GROUP" ]; then
            # Last resort: search all web apps
            RESOURCE_GROUP=$(az webapp list --query "[?name=='$APP_NAME'].resourceGroup" -o tsv 2>/dev/null | head -1 || echo "")
          fi
          
          if [ -z "$RESOURCE_GROUP" ]; then
            echo "‚ùå Error: Cannot determine resource group for web app '$APP_NAME'"
            echo "This indicates the web app may not exist or there's an authentication issue."
            echo ""
            echo "Available web apps:"
            az webapp list --query "[].{name:name, resourceGroup:resourceGroup}" -o table 2>/dev/null || echo "Could not list web apps"
            exit 1
          fi
          
          echo "‚úÖ Found resource group: $RESOURCE_GROUP"
          echo "üîç Final verification: Web app must be Running and Enabled before deployment..."
          
          # Get web app state with better error handling
          # Note: Use 'state' directly, not 'properties.state' (as shown by user testing)
          STATE_RESULT=$(az webapp show \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query state \
            -o tsv 2>&1)
          
          if echo "$STATE_RESULT" | grep -qi "error\|not found"; then
            echo "‚ùå Error: Failed to query web app state"
            echo "Azure CLI output: $STATE_RESULT"
            exit 1
          fi
          
          STATE="$STATE_RESULT"
          
          # Get enabled status
          # Note: Use 'enabled' directly, not 'properties.enabled' (as shown by user testing)
          ENABLED_RESULT=$(az webapp show \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query enabled \
            -o tsv 2>&1)
          
          if echo "$ENABLED_RESULT" | grep -qi "error\|not found"; then
            echo "‚ö†Ô∏è  Warning: Failed to query web app enabled status"
            ENABLED="false"
          else
            ENABLED="$ENABLED_RESULT"
          fi
          
          echo "State: ${STATE:-'(empty - this is an error)'}"
          echo "Enabled: ${ENABLED:-'(empty - this is an error)'}"
          
          # Handle empty values
          if [ -z "$STATE" ] || [ -z "$ENABLED" ]; then
            echo "‚ùå Error: Web app state queries returned empty values"
            echo "This indicates the web app may not exist or there's a configuration issue."
            echo ""
            echo "Full web app details:"
            az webapp show --resource-group $RESOURCE_GROUP --name $APP_NAME --output json 2>/dev/null | head -20 || echo "Could not retrieve web app details"
            exit 1
          fi
          
          if [ "$STATE" != "Running" ] || [ "$ENABLED" != "true" ]; then
            echo "‚ö†Ô∏è  Web app is not ready for deployment"
            echo "   State: $STATE (expected: Running)"
            echo "   Enabled: $ENABLED (expected: true)"
            echo ""
            echo "Attempting to start and enable the web app..."
            az webapp start --resource-group $RESOURCE_GROUP --name $APP_NAME --output none 2>/dev/null || true
            az webapp config set --resource-group $RESOURCE_GROUP --name $APP_NAME --always-on true --output none 2>/dev/null || true
            az webapp config set --resource-group $RESOURCE_GROUP --name $APP_NAME --set enabled=true --output none 2>/dev/null || true
            
            echo "‚è≥ Waiting 30 seconds for web app to be ready..."
            sleep 30
            
            # Re-check with error handling
            # Note: Use 'state' and 'enabled' directly, not 'properties.state' and 'properties.enabled'
            STATE=$(az webapp show --resource-group $RESOURCE_GROUP --name $APP_NAME --query state -o tsv 2>/dev/null || echo "")
            ENABLED=$(az webapp show --resource-group $RESOURCE_GROUP --name $APP_NAME --query enabled -o tsv 2>/dev/null || echo "")
            
            if [ -z "$STATE" ] || [ -z "$ENABLED" ]; then
              echo "‚ùå Error: Cannot query web app state after retry"
              echo "This indicates a serious issue with the web app or authentication."
              exit 1
            fi
            
            if [ "$STATE" != "Running" ] || [ "$ENABLED" != "true" ]; then
              echo "‚ùå Error: Web app is still not ready after retry"
              echo "   State: $STATE (expected: Running)"
              echo "   Enabled: $ENABLED (expected: true)"
              echo ""
              echo "Please check the Azure Portal and ensure the web app exists and is running."
              echo "Web app URL: https://portal.azure.com/#@/resource/subscriptions/*/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Web/sites/$APP_NAME"
              exit 1
            fi
          fi
          
          echo "‚úÖ Web app is ready for deployment (Running and Enabled)"

      - name: 'Deploy to Azure Web App'
        id: deploy-to-webapp
        timeout-minutes: 15
        continue-on-error: true
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'SmartWatts'
          slot-name: 'Production'
          package: ./deploy-package
          
      - name: Handle deployment result
        if: steps.deploy-to-webapp.outcome == 'failure'
        run: |
          echo "‚ö†Ô∏è  Deployment step failed, checking for conflict errors..."
          
          APP_NAME="SmartWatts"
          
          # Try multiple methods to find the resource group
          RESOURCE_GROUP=$(az webapp show --name $APP_NAME --query resourceGroup -o tsv 2>/dev/null || echo "")
          
          # If that fails, try searching for the web app
          if [ -z "$RESOURCE_GROUP" ]; then
            echo "‚ö†Ô∏è  Could not get resource group from webapp show, trying alternative method..."
            RESOURCE_GROUP=$(az webapp list --query "[?name=='$APP_NAME'].resourceGroup" -o tsv 2>/dev/null | head -1 || echo "")
          fi
          
          # If we still can't find it, try to list all web apps and search
          if [ -z "$RESOURCE_GROUP" ]; then
            echo "‚ö†Ô∏è  Could not determine resource group for web app '$APP_NAME'"
            echo "This might mean:"
            echo "  - The web app doesn't exist yet"
            echo "  - There's an authentication issue"
            echo "  - The web app name is incorrect"
            echo ""
            echo "Checking if this is a conflict error (409) from the deployment logs..."
            
            # Since we can't check active deployments without resource group,
            # we'll assume it's a conflict if the deployment action reported a 409
            # The azure/webapps-deploy action typically outputs "Conflict (CODE: 409)"
            echo "‚ö†Ô∏è  Unable to verify conflict status without resource group"
            echo "If the error above shows 'Conflict (CODE: 409)', this is a transient conflict."
            echo "The deployment will be retried on the next workflow run."
            echo ""
            echo "To resolve:"
            echo "  1. Check if the web app exists: az webapp list --query \"[?name=='$APP_NAME']\""
            echo "  2. Check the Azure Portal for stuck deployments"
            echo "  3. Verify the web app name is correct"
            
            # Can't determine resource group - this is a real error, fail the workflow
            echo "‚ùå Error: Cannot determine resource group for web app '$APP_NAME'"
            echo "This indicates a serious configuration or authentication issue."
            exit 1
          fi
          
          echo "‚úÖ Found resource group: $RESOURCE_GROUP"
          
          # Check if there are active deployments (which indicates a conflict)
          ACTIVE_DEPLOYMENTS=$(az webapp deployment list \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query "[?status=='Running' || status=='InProgress'].id" \
            -o tsv 2>/dev/null || echo "")
          
          if [ -n "$ACTIVE_DEPLOYMENTS" ]; then
            echo "‚ö†Ô∏è  Deployment conflict detected (409) - another deployment is in progress"
            echo "This is a transient conflict that will resolve automatically."
            echo "The deployment will be retried on the next workflow run."
            echo "If this persists, check the Azure Portal for stuck deployments."
            echo "Active deployment IDs: $ACTIVE_DEPLOYMENTS"
            exit 0  # Don't fail the workflow for conflicts
          fi
          
          # No active deployments but deployment failed - this is a real error
          echo "‚ùå Deployment failed and no active deployments found"
          echo "This appears to be a non-conflict error."
          echo ""
          
          # Check if this is a 403 "Site Disabled" error (using -o tsv instead of jq)
          echo "Checking web app state..."
          STATE=$(az webapp show \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query state \
            -o tsv 2>/dev/null || echo "Unknown")
          
          USAGE_STATE=$(az webapp show \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query properties.usageState \
            -o tsv 2>/dev/null || echo "Unknown")
          
          echo "Web app state: $STATE"
          echo "Usage state: $USAGE_STATE"
          
          if [ "$STATE" = "Stopped" ] || [ "$USAGE_STATE" = "Exceeded" ]; then
            echo ""
            echo "‚ö†Ô∏è  Error: Site Disabled (CODE: 403) - Web app is stopped or quota exceeded"
            echo "Attempting to start the web app..."
            az webapp start \
              --resource-group $RESOURCE_GROUP \
              --name $APP_NAME \
              --output none 2>/dev/null && echo "‚úÖ Web app started" || echo "‚ùå Could not start web app"
            echo ""
            echo "If the app was stopped, please retry the deployment."
            echo "If quota is exceeded, please resolve the quota issue in the Azure Portal."
            exit 1
          fi
          
          echo ""
          echo "Retrieving deployment logs..."
          
          # Get the latest deployment log
          DEPLOYMENT_ID=$(az webapp deployment list \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query "[0].id" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$DEPLOYMENT_ID" ]; then
            echo "Latest deployment ID: $DEPLOYMENT_ID"
            echo "Retrieving deployment log..."
            az webapp deployment log show \
              --resource-group $RESOURCE_GROUP \
              --name $APP_NAME \
              --deployment-id "$DEPLOYMENT_ID" 2>/dev/null | tail -50 || echo "Could not retrieve deployment log"
          fi
          
          echo ""
          echo "Checking web app configuration..."
          az webapp config show \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query "{linuxFxVersion:linuxFxVersion,appCommandLine:appCommandLine}" -o table 2>/dev/null || echo "Could not retrieve web app config"
          
          echo ""
          echo "Checking startup file setting..."
          STARTUP_FILE=$(az webapp config show \
            --resource-group $RESOURCE_GROUP \
            --name $APP_NAME \
            --query "appCommandLine" -o tsv 2>/dev/null || echo "")
          echo "Startup file: ${STARTUP_FILE:-'Not set'}"
          
          echo ""
          echo "Common causes:"
          echo "  - Invalid package structure"
          echo "  - Missing server.js or incorrect startup command"
          echo "  - Missing dependencies in standalone build"
          echo "  - Build errors"
          echo "  - Permission issues"
          echo "  - Web app configuration issues"
          echo ""
          echo "Please check the deployment logs above for specific error messages"
          exit 1
          