name: Deploy Production (prod branch)

on:
  push:
    branches: [ "prod" ]
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-prod-rg
  ENVIRONMENT: prod
  LOCATION: westeurope

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_PROD }}

    - name: Create Resource Group
      run: |
        az group create \
          --name ${{ env.AZURE_RESOURCE_GROUP }} \
          --location ${{ env.LOCATION }} \
          --output none

    - name: Register Required Resource Providers
      run: |
        az provider register --namespace microsoft.operationalinsights --wait
        az provider register --namespace microsoft.devices --wait
        az provider register --namespace microsoft.storage --wait
        az provider register --namespace microsoft.web --wait
        az provider register --namespace microsoft.keyvault --wait
        az provider register --namespace microsoft.network --wait

    - name: Deploy Infrastructure (Bicep)
      run: |
        az deployment group create \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --template-file infrastructure/bicep/main.bicep \
          --parameters @infrastructure/bicep/params.prod.json \
          --parameters vmAdminPassword="${{ secrets.VM_ADMIN_PASSWORD_PROD }}"

    - name: Get VM Public IP
      id: get-vm-ip
      run: |
        VM_IP=$(az vm show -d \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-vm \
          --query publicIps -o tsv)
        echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT

    - name: Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        # Write SSH private key - decode from base64 if needed
        SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_PROD }}"
        # Check if key starts with BEGIN marker (plain text PEM format)
        if echo "$SSH_KEY" | head -c 20 | grep -q "BEGIN"; then
          # Key is already in plain text PEM format
          echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/id_rsa
        else
          # Key appears to be base64 encoded - decode it
          echo "$SSH_KEY" | base64 -d > ~/.ssh/id_rsa
        fi
        chmod 600 ~/.ssh/id_rsa
        # Check key format and convert to PEM if needed
        KEY_START=$(head -c 20 ~/.ssh/id_rsa | xxd -p | tr -d '\n')
        # Check if key is in DER format (starts with 30 82 - ASN.1 SEQUENCE)
        if echo "$KEY_START" | grep -q "^3082"; then
          echo "Key is in DER format - converting to PEM format"
          # Convert DER to PEM using openssl
          openssl rsa -inform DER -in ~/.ssh/id_rsa -outform PEM -out ~/.ssh/id_rsa.pem 2>/dev/null && mv ~/.ssh/id_rsa.pem ~/.ssh/id_rsa || {
            echo "Warning: Could not convert DER key to PEM format, trying ssh-keygen"
            # Try using ssh-keygen to convert
            cp ~/.ssh/id_rsa ~/.ssh/id_rsa.der
            ssh-keygen -p -N "" -m PEM -f ~/.ssh/id_rsa.der > /dev/null 2>&1 && mv ~/.ssh/id_rsa.der ~/.ssh/id_rsa || {
              echo "Error: Could not convert DER key to PEM format"
              exit 1
            }
          }
        elif head -c 15 ~/.ssh/id_rsa | grep -q "openssh-key-v1"; then
          echo "Key is in OpenSSH format - converting to PEM format"
          # Convert OpenSSH format to PEM format (no passphrase change, just format conversion)
          ssh-keygen -p -N "" -m PEM -f ~/.ssh/id_rsa > /dev/null 2>&1 || {
            echo "Warning: Could not convert OpenSSH key to PEM format, trying to use as-is"
          }
        fi
        # Verify key can be read by ssh-keygen
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          # Try extracting public key as alternative validation
          if ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub 2>/dev/null; then
            echo "SSH key validated by extracting public key"
          else
            echo "Error: SSH key cannot be read by ssh-keygen"
            echo "Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
            echo "Number of lines: $(wc -l < ~/.ssh/id_rsa)"
            echo "First 50 characters (hex):"
            head -c 50 ~/.ssh/id_rsa | xxd | head -n 3
            exit 1
          fi
        else
          echo "SSH key validated successfully"
          # Extract public key
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
        fi
        ssh-keyscan -H ${{ steps.get-vm-ip.outputs.vm_ip }} >> ~/.ssh/known_hosts
        # Add public key to VM using Azure CLI
        echo "Adding public key to VM..."
        az vm user update \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-vm \
          --username azureuser \
          --ssh-key-value "$(cat ~/.ssh/id_rsa.pub)" 2>&1 || {
          echo "Note: Could not add public key via Azure CLI, will add via SSH during deployment"
        }
        # Also add public key directly via Azure VM run-command as fallback
        echo "Adding public key to VM authorized_keys via Azure run-command (fallback)..."
        PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)
        az vm run-command invoke \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-vm \
          --command-id RunShellScript \
          --scripts "sudo -u azureuser bash -c 'mkdir -p ~/.ssh && chmod 700 ~/.ssh && echo \"$PUBLIC_KEY\" >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys'" 2>&1 || echo "Note: Could not add public key via run-command (may already exist)"

    - name: Deploy Application to VM
      run: |
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa azureuser@${{ steps.get-vm-ip.outputs.vm_ip }} << 'EOF'
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
          fi
          
          # Install Docker Compose if not present
          if ! command -v docker-compose &> /dev/null; then
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          
          # Clone or update repository
          if [ -d "smartwatts" ]; then
            cd smartwatts
            git pull
          else
            git clone https://github.com/${{ github.repository }}.git smartwatts
            cd smartwatts
          fi
          
          # Deploy with Docker Compose
          cd azure-deployment
          docker-compose -f docker-compose.azure.yml up -d --build
        EOF

    - name: Deploy Frontend to Static Web Apps
      uses: Azure/static-web-apps-deploy@v1
      with:
        azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        action: "upload"
        app_location: "frontend"
        output_location: ".next"
        skip_app_build: false
        skip_api_build: true

    - name: Get Deployment Outputs
      run: |
        echo "VM Public IP: ${{ steps.get-vm-ip.outputs.vm_ip }}"
        echo "Static Web App URL: $(az staticwebapp show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-dashboard \
          --query defaultHostname -o tsv)"

    - name: Health Check
      run: |
        sleep 60  # Wait for services to start
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        curl -f http://$VM_IP:8080/actuator/health || exit 1

