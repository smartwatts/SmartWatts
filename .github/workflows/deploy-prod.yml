name: Deploy Production (prod branch)

on:
  # DISABLED - Production deployment is disabled
  # Use deploy-staging.yml for staging deployments
  # To enable production deployment, uncomment the workflow_dispatch line below
  # workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-prod-rg
  ENVIRONMENT: prod
  LOCATION: westeurope

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Check if workflow is disabled
        run: |
          if [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
            echo "❌ Error: This workflow is disabled"
            echo "   Production deployment is disabled. Use deploy-staging.yml for staging deployments."
            echo "   To enable, uncomment workflow_dispatch in the on: section"
            exit 1
          fi
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_PROD }}

    - name: Create Resource Group
      timeout-minutes: 2
      run: |
        # Check if resource group exists, create if it doesn't
        if ! az group show --name ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "Creating resource group..."
          az group create \
            --name ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.LOCATION }} \
            --output none
        else
          echo "Resource group already exists"
        fi

    - name: Register Required Resource Providers
      timeout-minutes: 5
      run: |
        # Only register if not already registered
        register_provider() {
          local provider=$1
          local status=$(az provider show --namespace $provider --query registrationState -o tsv 2>/dev/null || echo "NotRegistered")
          if [ "$status" != "Registered" ]; then
            echo "Registering $provider..."
            az provider register --namespace $provider --wait || {
              echo "Warning: Failed to register $provider, continuing..."
            }
          else
            echo "$provider is already registered"
          fi
        }
        
        register_provider microsoft.operationalinsights
        register_provider microsoft.devices
        register_provider microsoft.storage
        register_provider microsoft.web
        register_provider microsoft.keyvault
        register_provider microsoft.network

    - name: Deploy Infrastructure (Bicep)
      timeout-minutes: 20
      run: |
        # Retry deployment up to 3 times
        MAX_RETRIES=3
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if az deployment group create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --template-file infrastructure/bicep/main.bicep \
            --parameters @infrastructure/bicep/params.prod.json \
            --parameters vmAdminPassword="${{ secrets.VM_ADMIN_PASSWORD_PROD }}" \
            --name main; then
            echo "Infrastructure deployed successfully"
            exit 0
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Deployment failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
              sleep $((RETRY_COUNT * 10))
            else
              echo "Error: Infrastructure deployment failed after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done

    - name: Get VM Public IP
      id: get-vm-ip
      timeout-minutes: 2
      run: |
        VM_IP=$(az vm show -d \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-vm \
          --query publicIps -o tsv)
        if [ -z "$VM_IP" ]; then
          echo "Error: Failed to get VM public IP"
          exit 1
        fi
        echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
        echo "VM Public IP: $VM_IP"

    - name: Wait for VM Readiness
      timeout-minutes: 5
      run: |
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        MAX_WAIT=300  # 5 minutes
        WAIT_INTERVAL=10
        ELAPSED=0
        
        echo "Waiting for VM to be ready..."
        
        # Wait for VM to be in running state
        echo "Checking VM power state..."
        while [ $ELAPSED -lt $MAX_WAIT ]; do
          VM_STATE=$(az vm show -d \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-prod-vm \
            --query powerState -o tsv 2>/dev/null || echo "unknown")
          
          if [ "$VM_STATE" = "VM running" ]; then
            echo "VM is in running state"
            break
          else
            echo "VM state: $VM_STATE (waiting...)"
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
          fi
        done
        
        if [ "$VM_STATE" != "VM running" ]; then
          echo "Error: VM did not reach running state within timeout"
          exit 1
        fi
        
        # Wait for VM agent to be ready
        echo "Checking VM agent status..."
        ELAPSED=0
        while [ $ELAPSED -lt $MAX_WAIT ]; do
          AGENT_STATUS=$(az vm show -d \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-prod-vm \
            --query "instanceView.vmAgent.statuses[?code=='ProvisioningState/succeeded']" -o tsv 2>/dev/null || echo "")
          
          if [ -n "$AGENT_STATUS" ] && echo "$AGENT_STATUS" | grep -q "succeeded"; then
            echo "VM agent is ready"
            break
          else
            echo "VM agent not ready yet (waiting...)"
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
          fi
        done
        
        # Wait for SSH port 22 to be accessible
        echo "Checking SSH port 22 accessibility..."
        ELAPSED=0
        SSH_READY=false
        while [ $ELAPSED -lt $MAX_WAIT ]; do
          if timeout 5 bash -c "echo > /dev/tcp/$VM_IP/22" 2>/dev/null; then
            echo "SSH port 22 is accessible"
            SSH_READY=true
            break
          else
            echo "SSH port 22 not accessible yet (waiting...)"
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
          fi
        done
        
        if [ "$SSH_READY" != "true" ]; then
          echo "Error: SSH port 22 did not become accessible within timeout"
          echo "VM IP: $VM_IP"
          echo "VM State: $VM_STATE"
          exit 1
        fi
        
        # Additional wait for SSH service to be fully ready
        echo "Waiting for SSH service to be fully ready..."
        sleep 15
        
        echo "VM is ready for SSH connections"

    - name: Setup SSH Key
      timeout-minutes: 5
      run: |
        mkdir -p ~/.ssh
        # Write SSH private key - decode from base64 if needed
        SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_PROD }}"
        # Check if key starts with BEGIN marker (plain text PEM format)
        if echo "$SSH_KEY" | head -c 20 | grep -q "BEGIN"; then
          # Key is already in plain text PEM format
          echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/id_rsa
        else
          # Key appears to be base64 encoded - decode it
          echo "$SSH_KEY" | base64 -d > ~/.ssh/id_rsa
        fi
        chmod 600 ~/.ssh/id_rsa
        # Check key format and convert to PEM if needed
        KEY_START=$(head -c 20 ~/.ssh/id_rsa | xxd -p | tr -d '\n')
        # Check if key is in DER format (starts with 30 82 - ASN.1 SEQUENCE)
        if echo "$KEY_START" | grep -q "^3082"; then
          echo "Key is in DER format - converting to PEM format"
          # Convert DER to PEM using openssl
          openssl rsa -inform DER -in ~/.ssh/id_rsa -outform PEM -out ~/.ssh/id_rsa.pem 2>/dev/null && mv ~/.ssh/id_rsa.pem ~/.ssh/id_rsa || {
            echo "Warning: Could not convert DER key to PEM format, trying ssh-keygen"
            # Try using ssh-keygen to convert
            cp ~/.ssh/id_rsa ~/.ssh/id_rsa.der
            ssh-keygen -p -N "" -m PEM -f ~/.ssh/id_rsa.der > /dev/null 2>&1 && mv ~/.ssh/id_rsa.der ~/.ssh/id_rsa || {
              echo "Error: Could not convert DER key to PEM format"
              exit 1
            }
          }
        elif head -c 15 ~/.ssh/id_rsa | grep -q "openssh-key-v1"; then
          echo "Key is in OpenSSH format - converting to PEM format"
          # Convert OpenSSH format to PEM format (no passphrase change, just format conversion)
          ssh-keygen -p -N "" -m PEM -f ~/.ssh/id_rsa > /dev/null 2>&1 || {
            echo "Warning: Could not convert OpenSSH key to PEM format, trying to use as-is"
          }
        fi
        # Verify key can be read by ssh-keygen
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          # Try extracting public key as alternative validation
          if ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub 2>/dev/null; then
            echo "SSH key validated by extracting public key"
          else
            echo "Error: SSH key cannot be read by ssh-keygen"
            echo "Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
            echo "Number of lines: $(wc -l < ~/.ssh/id_rsa)"
            echo "First 50 characters (hex):"
            head -c 50 ~/.ssh/id_rsa | xxd | head -n 3
            exit 1
          fi
        else
          echo "SSH key validated successfully"
          # Extract public key
          ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
        fi
        # Add VM to known_hosts (non-blocking)
        ssh-keyscan -H ${{ steps.get-vm-ip.outputs.vm_ip }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add VM to known_hosts (will continue)"
        
        # Add public key to VM using Azure CLI
        echo "Adding public key to VM via Azure CLI..."
        PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)
        SSH_KEY_ADDED=false
        
        if az vm user update \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-vm \
          --username azureuser \
          --ssh-key-value "$PUBLIC_KEY" 2>&1; then
          echo "SSH key added successfully via Azure CLI"
          SSH_KEY_ADDED=true
        else
          echo "Azure CLI method failed, trying run-command..."
        fi
        
        # Fallback: Add public key directly via Azure VM run-command
        if [ "$SSH_KEY_ADDED" != "true" ]; then
          echo "Adding public key via Azure run-command (fallback)..."
          if az vm run-command invoke \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-prod-vm \
            --command-id RunShellScript \
            --scripts "sudo -u azureuser bash -c 'mkdir -p ~/.ssh && chmod 700 ~/.ssh && if ! grep -q \"$PUBLIC_KEY\" ~/.ssh/authorized_keys 2>/dev/null; then echo \"$PUBLIC_KEY\" >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys && echo \"SSH key added successfully\"; else echo \"SSH key already exists\"; fi'" 2>&1; then
            echo "SSH key added successfully via run-command"
            SSH_KEY_ADDED=true
          else
            echo "Error: Failed to add SSH key via both methods"
            exit 1
          fi
        fi
        
        # Wait for key propagation
        echo "Waiting for SSH key to propagate..."
        sleep 15
        
        # Verify SSH connection works
        echo "Verifying SSH connection..."
        MAX_RETRIES=5
        RETRY_COUNT=0
        SSH_CONNECTED=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if ssh -o StrictHostKeyChecking=no \
               -o UserKnownHostsFile=/dev/null \
               -o ConnectTimeout=15 \
               -o BatchMode=yes \
               -i ~/.ssh/id_rsa \
               azureuser@${{ steps.get-vm-ip.outputs.vm_ip }} \
               "echo 'SSH connection successful'" 2>/dev/null; then
            echo "SSH connection verified successfully"
            SSH_CONNECTED=true
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "SSH connection failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
              sleep $((RETRY_COUNT * 5))
            fi
          fi
        done
        
        if [ "$SSH_CONNECTED" != "true" ]; then
          echo "Error: SSH connection verification failed after $MAX_RETRIES attempts"
          echo "VM IP: ${{ steps.get-vm-ip.outputs.vm_ip }}"
          echo "VM State: $(az vm show -d --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name sw-prod-vm --query powerState -o tsv 2>/dev/null || echo 'unknown')"
          exit 1
        fi

    - name: Copy Repository to VM
      timeout-minutes: 5
      run: |
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        MAX_RETRIES=5
        RETRY_COUNT=0
        
        # Create tarball of repository
        echo "Creating repository tarball..."
        tar czf /tmp/smartwatts.tar.gz --exclude='.git' --exclude='node_modules' --exclude='.next' . || {
          echo "Error: Failed to create repository tarball"
          exit 1
        }
        
        # Copy repository to VM with retry logic
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Copying repository to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
          if scp -o StrictHostKeyChecking=no \
               -o UserKnownHostsFile=/dev/null \
               -o ConnectTimeout=15 \
               -i ~/.ssh/id_rsa \
               /tmp/smartwatts.tar.gz \
               azureuser@$VM_IP:/tmp/ 2>&1; then
            echo "Repository copied successfully"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Copy failed, retrying in $((RETRY_COUNT * 5)) seconds..."
              sleep $((RETRY_COUNT * 5))
            else
              echo "Error: Failed to copy repository after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done
        
        # Extract repository on VM with retry logic
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Extracting repository on VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
          EXTRACT_SCRIPT=$(printf 'cd /home/azureuser\nif [ -d "smartwatts" ]; then\n  rm -rf smartwatts\nfi\nmkdir -p smartwatts\ncd smartwatts\ntar xzf /tmp/smartwatts.tar.gz\nrm /tmp/smartwatts.tar.gz\necho "Repository extracted successfully"')
          if ssh -o StrictHostKeyChecking=no \
               -o UserKnownHostsFile=/dev/null \
               -o ConnectTimeout=15 \
               -i ~/.ssh/id_rsa \
               azureuser@$VM_IP "$EXTRACT_SCRIPT"; then
            echo "Repository extracted successfully"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Extraction failed, retrying in $((RETRY_COUNT * 5)) seconds..."
              sleep $((RETRY_COUNT * 5))
            else
              echo "Error: Failed to extract repository after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done

    - name: Deploy Application to VM
      timeout-minutes: 30
      run: |
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        MAX_RETRIES=3
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Deploying application to VM (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
          DEPLOY_SCRIPT=$(printf '%s\n' \
            'if ! command -v docker &> /dev/null; then' \
            '  echo "Installing Docker...";' \
            '  sudo apt-get update -qq;' \
            '  sudo apt-get install -y -qq ca-certificates curl gnupg lsb-release || true;' \
            '  sudo mkdir -p /etc/apt/keyrings;' \
            '  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg;' \
            '  echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null;' \
            '  sudo apt-get update -qq;' \
            '  sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {' \
            '    echo "Docker CE installation failed, trying docker.io...";' \
            '    sudo apt-get install -y -qq docker.io docker-compose || { echo "Error: Docker installation failed"; exit 1; };' \
            '  };' \
            '  if ! command -v docker &> /dev/null; then' \
            '    echo "Error: Docker installation failed - docker command not found";' \
            '    exit 1;' \
            '  fi;' \
            '  if getent group docker > /dev/null 2>&1; then sudo usermod -aG docker $USER; fi;' \
            '  echo "Docker installed successfully";' \
            'fi;' \
            'if systemctl list-unit-files | grep -q docker.service; then' \
            '  sudo systemctl start docker || true;' \
            '  sudo systemctl enable docker || true;' \
            'else' \
            '  if ! sudo docker info > /dev/null 2>&1; then' \
            '    echo "Warning: Docker service not found, but Docker may still work";' \
            '    sudo dockerd > /dev/null 2>&1 &' \
            '    sleep 5;' \
            '  fi;' \
            'fi;' \
            'if ! sudo docker info > /dev/null 2>&1; then' \
            '  echo "Error: Docker daemon is not running";' \
            '  exit 1;' \
            'fi;' \
            'echo "Docker is installed and running";' \
            'if ! command -v docker-compose &> /dev/null && ! (command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1); then' \
            '  sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose;' \
            '  sudo chmod +x /usr/local/bin/docker-compose;' \
            'fi;' \
            'cd /home/azureuser/smartwatts;' \
            'echo "Verifying Gradle wrapper files exist...";' \
            'MISSING_FILES=0;' \
            'for service_dir in backend/*-service backend/*-gateway backend/service-discovery; do' \
            '  if [ -d "$service_dir" ]; then' \
            '    if [ ! -f "$service_dir/gradle/wrapper/gradle-wrapper.jar" ]; then' \
            '      echo "ERROR: Missing gradle-wrapper.jar in $service_dir";' \
            '      MISSING_FILES=$((MISSING_FILES + 1));' \
            '    else' \
            '      echo "✓ Found gradle-wrapper.jar in $service_dir";' \
            '    fi;' \
            '  fi;' \
            'done;' \
            'if [ $MISSING_FILES -gt 0 ]; then' \
            '  echo "ERROR: $MISSING_FILES service(s) missing gradle-wrapper.jar files";' \
            '  echo "Listing backend directory structure:";' \
            '  find backend -name "gradle-wrapper.jar" -type f || echo "No gradle-wrapper.jar files found";' \
            '  exit 1;' \
            'fi;' \
            'echo "All Gradle wrapper files verified successfully";' \
            'cd azure-deployment;' \
            'sudo docker-compose -f docker-compose.azure.yml up -d --build;' \
            'echo "Application deployed successfully"')
          if ssh -o StrictHostKeyChecking=no \
               -o UserKnownHostsFile=/dev/null \
               -o ConnectTimeout=15 \
               -i ~/.ssh/id_rsa \
               azureuser@$VM_IP "$DEPLOY_SCRIPT"; then
            echo "Application deployed successfully"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Deployment failed, retrying in $((RETRY_COUNT * 10)) seconds..."
              sleep $((RETRY_COUNT * 10))
            else
              echo "Error: Failed to deploy application after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done

    - name: Deploy Frontend to Static Web Apps
      timeout-minutes: 10
      continue-on-error: true
      uses: Azure/static-web-apps-deploy@v1
      with:
        azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        action: "upload"
        app_location: "frontend"
        output_location: ".next"
        skip_app_build: false
        skip_api_build: true

    - name: Get Deployment Outputs
      run: |
        echo "VM Public IP: ${{ steps.get-vm-ip.outputs.vm_ip }}"
        echo "Static Web App URL: $(az staticwebapp show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-dashboard \
          --query defaultHostname -o tsv)"

    - name: Health Check
      timeout-minutes: 5
      run: |
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        MAX_RETRIES=10
        RETRY_COUNT=0
        WAIT_INTERVAL=10
        
        echo "Waiting for services to start and checking health..."
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if curl -f -s --max-time 5 http://$VM_IP:8080/actuator/health > /dev/null 2>&1; then
            echo "Health check passed"
            exit 0
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Health check failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
              sleep $WAIT_INTERVAL
            fi
          fi
        done
        
        echo "Error: Health check failed after $MAX_RETRIES attempts"
        exit 1

