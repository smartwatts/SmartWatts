name: Deploy Production (prod branch)

on:
  push:
    branches: [ "prod" ]
  workflow_dispatch:

env:
  AZURE_RESOURCE_GROUP: sw-prod-rg
  ENVIRONMENT: prod
  LOCATION: westeurope

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Validate Required Secrets
      run: |
        MISSING_SECRETS=0
        if [ -z "${{ secrets.AZURE_CREDENTIALS_PROD }}" ]; then
          echo "Error: AZURE_CREDENTIALS_PROD secret is missing"
          MISSING_SECRETS=$((MISSING_SECRETS + 1))
        fi
        if [ -z "${{ secrets.VM_ADMIN_PASSWORD_PROD }}" ]; then
          echo "Error: VM_ADMIN_PASSWORD_PROD secret is missing"
          MISSING_SECRETS=$((MISSING_SECRETS + 1))
        fi
        if [ -z "${{ secrets.VM_SSH_PRIVATE_KEY_PROD }}" ]; then
          echo "Error: VM_SSH_PRIVATE_KEY_PROD secret is missing"
          MISSING_SECRETS=$((MISSING_SECRETS + 1))
        fi
        if [ -z "${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}" ]; then
          echo "Error: AZURE_STATIC_WEB_APPS_API_TOKEN_PROD secret is missing"
          MISSING_SECRETS=$((MISSING_SECRETS + 1))
        fi
        
        if [ $MISSING_SECRETS -gt 0 ]; then
          echo "Error: $MISSING_SECRETS required secret(s) are missing"
          exit 1
        fi
        echo "✓ All required secrets are present"

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS_PROD }}

    - name: Create Resource Group
      run: |
        # Check if resource group exists, create if it doesn't
        if az group show --name ${{ env.AZURE_RESOURCE_GROUP }} --output none 2>/dev/null; then
          echo "Resource group ${{ env.AZURE_RESOURCE_GROUP }} already exists"
        else
          echo "Creating resource group ${{ env.AZURE_RESOURCE_GROUP }}..."
          az group create \
            --name ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.LOCATION }} \
            --output none
        fi

    - name: Register Required Resource Providers
      run: |
        register_provider() {
          local namespace=$1
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if az provider register --namespace "$namespace" --wait; then
              echo "Successfully registered $namespace"
              return 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Failed to register $namespace, retrying in 5 seconds..."
                sleep 5
              else
                echo "Warning: Failed to register $namespace after $MAX_RETRIES attempts"
                return 1
              fi
            fi
          done
        }
        
        register_provider microsoft.operationalinsights
        register_provider microsoft.devices
        register_provider microsoft.storage
        register_provider microsoft.web
        register_provider microsoft.keyvault
        register_provider microsoft.network

    - name: Deploy Infrastructure (Bicep)
      run: |
        MAX_RETRIES=3
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Deploying infrastructure (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
          
          if az deployment group create \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --template-file infrastructure/bicep/main.bicep \
            --parameters @infrastructure/bicep/params.prod.json \
            --parameters vmAdminPassword="${{ secrets.VM_ADMIN_PASSWORD_PROD }}" \
            --output none; then
            echo "Infrastructure deployment succeeded"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Deployment failed, retrying in 10 seconds..."
              sleep 10
            else
              echo "Error: Infrastructure deployment failed after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done
        
        # Validate deployment outputs
        echo "Validating deployment outputs..."
        DEPLOYMENT_OUTPUTS=$(az deployment group show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name main \
          --query properties.outputs -o json 2>/dev/null || echo "{}")
        
        if [ "$DEPLOYMENT_OUTPUTS" = "{}" ]; then
          echo "Warning: Could not retrieve deployment outputs"
        else
          echo "Deployment outputs retrieved successfully"
        fi

    - name: Get VM Public IP
      id: get-vm-ip
      run: |
        VM_IP=$(az vm show -d \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-vm \
          --query publicIps -o tsv)
        if [ -z "$VM_IP" ]; then
          echo "Error: Failed to get VM public IP"
          exit 1
        fi
        echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
        echo "VM Public IP: $VM_IP"

    - name: Wait for VM Readiness
      run: |
        echo "Waiting for VM to be in running state..."
        MAX_RETRIES=30
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          VM_STATE=$(az vm show -d \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name sw-prod-vm \
            --query powerState -o tsv 2>/dev/null || echo "unknown")
          
          if [ "$VM_STATE" = "VM running" ]; then
            echo "VM is running"
            break
          fi
          
          RETRY_COUNT=$((RETRY_COUNT + 1))
          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
            echo "VM state: $VM_STATE (attempt $RETRY_COUNT/$MAX_RETRIES), waiting 10 seconds..."
            sleep 10
          else
            echo "Error: VM did not reach running state after $MAX_RETRIES attempts"
            exit 1
          fi
        done
        
        # Additional wait for VM agent to be ready
        echo "Waiting for VM agent to be ready..."
        sleep 15

    - name: Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        # Write SSH private key - decode from base64 if needed
        SSH_KEY="${{ secrets.VM_SSH_PRIVATE_KEY_PROD }}"
        # Check if key starts with BEGIN marker (plain text PEM format)
        if echo "$SSH_KEY" | head -c 20 | grep -q "BEGIN"; then
          # Key is already in plain text PEM format
          echo "$SSH_KEY" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/id_rsa
        else
          # Key appears to be base64 encoded - decode it
          echo "$SSH_KEY" | base64 -d > ~/.ssh/id_rsa
        fi
        chmod 600 ~/.ssh/id_rsa
        # Check key format and convert to PEM if needed
        KEY_START=$(head -c 20 ~/.ssh/id_rsa | xxd -p | tr -d '\n')
        # Check if key is in DER format (starts with 30 82 - ASN.1 SEQUENCE)
        if echo "$KEY_START" | grep -q "^3082"; then
          echo "Key is in DER format - converting to PEM format"
          # Convert DER to PEM using openssl
          openssl rsa -inform DER -in ~/.ssh/id_rsa -outform PEM -out ~/.ssh/id_rsa.pem 2>/dev/null && mv ~/.ssh/id_rsa.pem ~/.ssh/id_rsa || {
            echo "Warning: Could not convert DER key to PEM format, trying ssh-keygen"
            # Try using ssh-keygen to convert
            cp ~/.ssh/id_rsa ~/.ssh/id_rsa.der
            ssh-keygen -p -N "" -m PEM -f ~/.ssh/id_rsa.der > /dev/null 2>&1 && mv ~/.ssh/id_rsa.der ~/.ssh/id_rsa || {
              echo "Error: Could not convert DER key to PEM format"
              exit 1
            }
          }
        elif head -c 15 ~/.ssh/id_rsa | grep -q "openssh-key-v1"; then
          echo "Key is in OpenSSH format - converting to PEM format"
          # Convert OpenSSH format to PEM format (no passphrase change, just format conversion)
          ssh-keygen -p -N "" -m PEM -f ~/.ssh/id_rsa > /dev/null 2>&1 || {
            echo "Warning: Could not convert OpenSSH key to PEM format, trying to use as-is"
          }
        fi
        # Verify key can be read by ssh-keygen
        if ! ssh-keygen -l -f ~/.ssh/id_rsa > /dev/null 2>&1; then
          # Try extracting public key as alternative validation
          if ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub 2>/dev/null; then
            echo "SSH key validated by extracting public key"
          else
            echo "Error: SSH key cannot be read by ssh-keygen"
            echo "Key file size: $(wc -c < ~/.ssh/id_rsa) bytes"
            echo "Number of lines: $(wc -l < ~/.ssh/id_rsa)"
            echo "First 50 characters (hex):"
            head -c 50 ~/.ssh/id_rsa | xxd | head -n 3
            exit 1
          fi
        else
          echo "SSH key validated successfully"
          # Extract public key
          if ! ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub 2>/dev/null; then
            echo "Error: Failed to extract public key from private key"
            exit 1
          fi
        fi
        # Add VM to known_hosts (non-blocking)
        ssh-keyscan -H ${{ steps.get-vm-ip.outputs.vm_ip }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add VM to known_hosts (will continue)"
        # Add public key to VM using Azure CLI
        echo "Adding public key to VM..."
        az vm user update \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-vm \
          --username azureuser \
          --ssh-key-value "$(cat ~/.ssh/id_rsa.pub)" 2>&1 || {
          echo "Note: Could not add public key via Azure CLI, will add via SSH during deployment"
        }
        # Also add public key directly via Azure VM run-command as fallback
        # Note: This may fail if VM agent isn't ready, but SSH will still work
        echo "Adding public key to VM authorized_keys via Azure run-command (fallback)..."
        PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)
        timeout 30 az vm run-command invoke \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-vm \
          --command-id RunShellScript \
          --scripts "sudo -u azureuser bash -c 'mkdir -p ~/.ssh && chmod 700 ~/.ssh && echo \"$PUBLIC_KEY\" >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys'" 2>&1 || echo "Note: Could not add public key via run-command (VM agent may not be ready - SSH will still work)"

    - name: Copy Repository to VM
      run: |
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        MAX_RETRIES=5
        RETRY_COUNT=0
        
        # Retry SSH connection with exponential backoff
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i ~/.ssh/id_rsa azureuser@$VM_IP "echo 'SSH connection successful'" 2>/dev/null; then
            echo "SSH connection established"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 5))
              echo "SSH connection failed (attempt $RETRY_COUNT/$MAX_RETRIES), waiting ${WAIT_TIME}s..."
              sleep $WAIT_TIME
            else
              echo "Error: Failed to establish SSH connection after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done
        
        # Create tarball of repository
        echo "Creating repository tarball..."
        tar czf /tmp/smartwatts.tar.gz --exclude='.git' --exclude='node_modules' --exclude='.next' .
        
        # Copy repository to VM with retry
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if scp -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i ~/.ssh/id_rsa /tmp/smartwatts.tar.gz azureuser@$VM_IP:/tmp/ 2>/dev/null; then
            echo "Repository copied successfully"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 5))
              echo "Copy failed (attempt $RETRY_COUNT/$MAX_RETRIES), waiting ${WAIT_TIME}s..."
              sleep $WAIT_TIME
            else
              echo "Error: Failed to copy repository after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done
        
        # Extract repository on VM
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa azureuser@$VM_IP << 'EOF'
          cd /home/azureuser
          if [ -d "smartwatts" ]; then
            rm -rf smartwatts
          fi
          mkdir -p smartwatts
          cd smartwatts
          tar xzf /tmp/smartwatts.tar.gz
          rm /tmp/smartwatts.tar.gz
          echo "Repository extracted successfully"
        EOF

    - name: Deploy Application to VM
      timeout-minutes: 30
      run: |
        ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa azureuser@${{ steps.get-vm-ip.outputs.vm_ip }} << 'EOF'
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            # Use apt-get to install Docker (more reliable for Ubuntu 20.04)
            sudo apt-get update -qq
            sudo apt-get install -y -qq \
              ca-certificates \
              curl \
              gnupg \
              lsb-release || true
            
            # Add Docker's official GPG key
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            
            # Set up Docker repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
              $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Install Docker
            sudo apt-get update -qq
            sudo apt-get install -y -qq docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin || {
              echo "Docker CE installation failed, trying docker.io..."
              sudo apt-get install -y -qq docker.io docker-compose || {
                echo "Error: Docker installation failed"
                exit 1
              }
            }
            
            # Verify Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Error: Docker installation failed - docker command not found"
              exit 1
            fi
            
            # Add user to docker group (only if group exists)
            if getent group docker > /dev/null 2>&1; then
              sudo usermod -aG docker $USER
            fi
            echo "Docker installed successfully"
          fi
          
          # Start Docker service if not running
          # Check if Docker service exists before trying to start it
          if systemctl list-unit-files | grep -q docker.service; then
            sudo systemctl start docker || true
            sudo systemctl enable docker || true
          else
            # If service doesn't exist, try starting dockerd directly or check if Docker is already running
            if ! sudo docker info > /dev/null 2>&1; then
              echo "Warning: Docker service not found, but Docker may still work"
              # Try to start Docker daemon manually
              sudo dockerd > /dev/null 2>&1 &
              sleep 5
            fi
          fi
          
          # Verify Docker is working
          if ! sudo docker info > /dev/null 2>&1; then
            echo "Error: Docker daemon is not running"
            exit 1
          fi
          echo "Docker is installed and running"
          
          # Install Docker Compose if not present
          if ! command -v docker-compose &> /dev/null && ! (command -v docker &> /dev/null && docker compose version &> /dev/null 2>&1); then
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          
          # Navigate to repository
          cd /home/azureuser/smartwatts
          
          # Verify Gradle wrapper files exist before building
          echo "Verifying Gradle wrapper files exist..."
          MISSING_FILES=0
          for service_dir in backend/*-service backend/*-gateway backend/service-discovery; do
            if [ -d "$service_dir" ]; then
              if [ ! -f "$service_dir/gradle/wrapper/gradle-wrapper.jar" ]; then
                echo "ERROR: Missing gradle-wrapper.jar in $service_dir"
                MISSING_FILES=$((MISSING_FILES + 1))
              else
                echo "✓ Found gradle-wrapper.jar in $service_dir"
              fi
            fi
          done
          
          if [ $MISSING_FILES -gt 0 ]; then
            echo "ERROR: $MISSING_FILES service(s) missing gradle-wrapper.jar files"
            echo "Listing backend directory structure:"
            find backend -name "gradle-wrapper.jar" -type f || echo "No gradle-wrapper.jar files found"
            exit 1
          fi
          
          echo "All Gradle wrapper files verified successfully"
          
          # Deploy with Docker Compose (use sudo since group membership may not be active)
          cd azure-deployment
          sudo docker-compose -f docker-compose.azure.yml up -d --build
        EOF

    - name: Deploy Frontend to Static Web Apps
      continue-on-error: true
      uses: Azure/static-web-apps-deploy@v1
      with:
        azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
        repo_token: ${{ secrets.GITHUB_TOKEN }}
        action: "upload"
        app_location: "frontend"
        output_location: ".next"
        skip_app_build: false
        skip_api_build: true

    - name: Get Deployment Outputs
      run: |
        echo "VM Public IP: ${{ steps.get-vm-ip.outputs.vm_ip }}"
        echo "Static Web App URL: $(az staticwebapp show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-dashboard \
          --query defaultHostname -o tsv)"

    - name: Health Check
      run: |
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        MAX_RETRIES=10
        RETRY_COUNT=0
        RETRY_DELAY=10
        
        echo "Waiting for services to start and checking health..."
        
        # Check API Gateway health
        API_GATEWAY_HEALTHY=false
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if curl -f -s http://$VM_IP:8080/actuator/health > /dev/null 2>&1; then
            echo "✓ API Gateway is healthy"
            API_GATEWAY_HEALTHY=true
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "API Gateway not ready (attempt $RETRY_COUNT/$MAX_RETRIES), waiting ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          fi
        done
        
        # Check Service Discovery health
        SERVICE_DISCOVERY_HEALTHY=false
        RETRY_COUNT=0
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if curl -f -s http://$VM_IP:8761/actuator/health > /dev/null 2>&1; then
            echo "✓ Service Discovery is healthy"
            SERVICE_DISCOVERY_HEALTHY=true
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Service Discovery not ready (attempt $RETRY_COUNT/$MAX_RETRIES), waiting ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          fi
        done
        
        # Final validation
        if [ "$API_GATEWAY_HEALTHY" = "true" ] && [ "$SERVICE_DISCOVERY_HEALTHY" = "true" ]; then
          echo "✓ All critical services are healthy"
          exit 0
        else
          echo "Error: Some services failed health check"
          echo "API Gateway: $API_GATEWAY_HEALTHY"
          echo "Service Discovery: $SERVICE_DISCOVERY_HEALTHY"
          exit 1
        fi

    - name: Deployment Summary
      if: always()
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        VM_IP="${{ steps.get-vm-ip.outputs.vm_ip }}"
        if [ -n "$VM_IP" ]; then
          echo "### VM Information" >> $GITHUB_STEP_SUMMARY
          echo "- **VM Public IP**: $VM_IP" >> $GITHUB_STEP_SUMMARY
          echo "- **API Gateway URL**: http://$VM_IP:8080" >> $GITHUB_STEP_SUMMARY
          echo "- **Service Discovery URL**: http://$VM_IP:8761" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        STATIC_WEB_APP_URL=$(az staticwebapp show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name sw-prod-dashboard \
          --query defaultHostname -o tsv 2>/dev/null || echo "N/A")
        
        if [ "$STATIC_WEB_APP_URL" != "N/A" ]; then
          echo "### Static Web App" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: https://$STATIC_WEB_APP_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "### Deployment Status" >> $GITHUB_STEP_SUMMARY
        if [ "${{ job.status }}" = "success" ]; then
          echo "✅ **Deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ **Deployment failed or was cancelled**" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Verify all services are running: \`curl http://$VM_IP:8080/actuator/health\`" >> $GITHUB_STEP_SUMMARY
        echo "2. Access the dashboard at: https://$STATIC_WEB_APP_URL" >> $GITHUB_STEP_SUMMARY
        echo "3. Monitor services in Azure Portal" >> $GITHUB_STEP_SUMMARY

